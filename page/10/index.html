<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-01-Java基础/02-集合源码/03-Set源码解读" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/02-%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/03-Set%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/02-%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/03-Set%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Set源码解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>基于HashMap实现 ，非线程安全</p>
<h1 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h1><p>基于CopyOnWriteArrayList，线程安全</p>
<h1 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h1><p>基于ConcurrentSkipListMap，线程安全，有序，查询快</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/02-%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/03-Set%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" data-id="clmcxecp80067u8waaa6b44zd" data-title="Set源码解析" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" rel="tag">集合源码</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-01-Java基础/02-集合源码/04-Queue源码解读" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/02-%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/04-Queue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/02-%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/04-Queue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">Queue源码解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Queue-API"><a href="#Queue-API" class="headerlink" title="Queue API"></a>Queue API</h1><p>Queue –队列数据结构的实现。分为阻塞队列和非阻塞队列。下列的红色字体，为阻塞队列特有方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>增加一个元索</td>
<td>如果队列已满，则抛出一个IIIegaISlabEepeplian异常</td>
</tr>
<tr>
<td>remove</td>
<td>移除并返回队列头部的元素</td>
<td>如果队列为空，则抛出一个NoSuchElementException异常</td>
</tr>
<tr>
<td>element</td>
<td>返回队列头部的元素</td>
<td>如果队列为空，则抛出一个NoSuchElementException异常</td>
</tr>
<tr>
<td>offer</td>
<td>添加一个元素并返回true</td>
<td>如果队列已满，则返回false</td>
</tr>
<tr>
<td>poll</td>
<td>移除并返问队列头部的元素</td>
<td>如果队列为空，则返回null</td>
</tr>
<tr>
<td>peek</td>
<td>返回队列头部的元素</td>
<td>如果队列为空，则返回null</td>
</tr>
<tr>
<td><span style="color:red">put</span></td>
<td>添加一个元素</td>
<td>如果队列满，则阻塞</td>
</tr>
<tr>
<td><span style="color:red">take</span></td>
<td>移除并返回队列头部的元素</td>
<td>如果队列为空，则阻塞</td>
</tr>
</tbody></table>
<h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><ul>
<li>使用ReentrantLock保证线程安全</li>
<li>环形数组存储</li>
<li>阻塞队列</li>
<li>长度固定</li>
</ul>
<h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><ul>
<li>使用ReentrantLock保证线程安全</li>
<li>链表存储</li>
<li>阻塞队列</li>
<li>可指定队列长度，不指定则为无界队列，长度为Integer.MAX_VALUE</li>
</ul>
<h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><ul>
<li>使用CAS保证线程安全</li>
<li>链表存储</li>
<li>非阻塞队列</li>
<li>无界队列</li>
</ul>
<h1 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h1><ul>
<li>线程安全</li>
<li>阻塞队列</li>
<li>长度为0</li>
</ul>
<ol>
<li>put时会阻塞，直到被get</li>
<li>take会阻塞，直到取到元素</li>
<li>offer的元素可能会丢失</li>
<li>poll取不到元素，就返回null,如果正好有put被阻塞，可以取到</li>
<li>peek永远只能取到null，不能让take结束阻塞</li>
</ol>
<h1 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><p>优先级队列，默认按自然数排序，可以通过Comparator指定排序方式</p>
<ul>
<li>使用ReentrantLock保证线程安全</li>
<li>数组存储</li>
<li>阻塞队列</li>
<li>长度默认11，可指定长度</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/02-%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/04-Queue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" data-id="clmcxecph006au8waep6x2l0k" data-title="Queue源码解析" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" rel="tag">集合源码</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-01-Java基础/03-注解/01-注解原理及使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/03-%E6%B3%A8%E8%A7%A3/01-%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/03-%E6%B3%A8%E8%A7%A3/01-%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/">注解原理及使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="注解关概念"><a href="#注解关概念" class="headerlink" title="注解关概念"></a>注解关概念</h1><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><ul>
<li><strong>Java语言规定，注解使用@interface修饰</strong></li>
<li><strong>Java中的注解是继承了Annotation的特殊的接口</strong></li>
</ul>
<h2 id="为什么使用注解"><a href="#为什么使用注解" class="headerlink" title="为什么使用注解?"></a>为什么使用注解?</h2><p>spring刚开始使用xml作为配置来定义bean，随着bean越来越多配置文件越来越臃肿，查看代码需要和配置文件结合看。后面spring引入注解相关的配置支持来解决代码阅读难、配置臃肿问题。</p>
<p><strong>优点</strong></p>
<ol>
<li>代码阅读变得直观，易懂与源代码耦合</li>
<li>配置更加简单方便</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>注解分散到很多类中，不好管理和维护</li>
<li>注解的开启&#x2F;关闭必须修改源代码</li>
</ol>
<h2 id="为什么需要学习注解？"><a href="#为什么需要学习注解？" class="headerlink" title="为什么需要学习注解？"></a>为什么需要学习注解？</h2><p>注解虽然有缺点，但是我门在使用注解时使用它的优点，将注解和配置文件结合使用，把经常需要修改的配置放到配置文件中使用它们的优点。</p>
<h1 id="注解组成"><a href="#注解组成" class="headerlink" title="注解组成"></a>注解组成</h1><h2 id="注解的体系结构认识"><a href="#注解的体系结构认识" class="headerlink" title="注解的体系结构认识"></a>注解的体系结构认识</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210911164842.png"></p>
<h2 id="四大元注解"><a href="#四大元注解" class="headerlink" title="四大元注解"></a>四大元注解</h2><p><strong>注解的注解且只能作用于注解上的注解</strong> </p>
<ul>
<li><p><strong>@Target [取值ElementType枚举]</strong></p>
<p>定义注解的使用的元素 </p>
<p>例如：ElementType.TYPE 作用于类上，ElementType.METHOD作用于方法上，等等</p>
</li>
<li><p><strong>@Retention [取值RetentionPolicy枚举]</strong></p>
<p>定义注解的保留策略</p>
<p>例如：SOURCE 源代码，CLASS class文件，RUNTIME 运行时，优先级顺序：SOURCE &lt; CLASS &lt; RUNTIME。只有RUNTIME修饰的注解才可以通过反射获取到注解信息</p>
</li>
<li><p><strong>@Documented</strong> </p>
<p>标记使用的注解是否包含在生成的用户文档中</p>
<p>例如：JavaDoc生成</p>
</li>
<li><p><strong>@Inherited</strong> </p>
<p>注解是否具有继承的特性</p>
<p>例如：在一个Man接口的实现类上加@MarkMan注解标识男人，有一个实现类则需要再添加一个@MarkMan注解，可以把@MarkMan注解放在Man接口上，在@MarkMan注解上添加@Inherited修饰符号表示该注解可以被继承。</p>
</li>
<li><p><strong>@Repeatable</strong></p>
<p>相同的程序元素中重复注解(jdk8新增注解)</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Roles(value = &#123;@Role(roleName = &quot;爸爸&quot;), @Role(roleName = &quot;工人&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能在类上使用相同的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Role(roleName = &quot;爸爸&quot;)</span></span><br><span class="line"><span class="meta">@Role(roleName = &quot;工人&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在注解上添加@Repeatable修饰符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(Roles.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Role &#123;</span><br><span class="line">    String <span class="title function_">roleName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Roles &#123;</span><br><span class="line">    Role[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际最终编译时还是转换为以下代码</p>
<pre><code class="java">package com.dongnao.annotation.demo8;

@Roles(&#123;@Role(
    roleName = &quot;爸爸&quot;
), @Role(
    roleName = &quot;工人&quot;
)&#125;)
public class Man &#123;
    public Man() &#123;
    &#125;
&#125;
</code></pre>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/03-%E6%B3%A8%E8%A7%A3/01-%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/" data-id="clmcxecr1006du8wa4hw364wx" data-title="注解原理及使用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag">注解</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-01-Java基础/04-设计模式/02-设计模式（二）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/04-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/04-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/">设计模式（二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul>
<li><p><strong>示例：</strong></p>
<p>请为你的系统设计一个命令行界面，用户可输入命令来执行某项功能 </p>
<p>系统的功能会不断添加，命令也会不断增加。</p>
<p>如何将一项一项的功能加入到这个命令行界面?</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724195339.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724195411.png"></p>
<p>如何让我们的命令行程序写好后，不因功能的添加而修改，又可灵活加入命令、功能。请为此做设计。</p>
<h2 id="命令模式-类图"><a href="#命令模式-类图" class="headerlink" title="命令模式-类图"></a>命令模式-类图</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724200918.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724200952.png"></p>
<ul>
<li><p><strong>命令模式</strong></p>
<p>以命令的方式，解耦调用者与功能的具体实现者，降低系统耦合度，提供了灵活性。</p>
</li>
<li><p><strong>适用场景：交互场景</strong></p>
<p>示例∶Servlet、Controller、线程池</p>
</li>
</ul>
<h2 id="命令模式-策略模式的区别"><a href="#命令模式-策略模式的区别" class="headerlink" title="命令模式-策略模式的区别"></a>命令模式-策略模式的区别</h2><ul>
<li><p>策略模式侧重的是<strong>一个行为</strong>的多个算法实现，可互换算法。 </p>
</li>
<li><p>命令模式侧重的是为<strong>多个行为</strong>提供灵活的执行方式。</p>
</li>
</ul>
<p>  </p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724200918.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210720215841.png"></p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><ul>
<li><p><strong>示例：</strong>一个类对外提供了多个行为，同时该类对象有多种状态，不同状态下对外的行为的表现不同，我们该如何来设计该类让它对状态可以灵活扩展?</p>
<p>如请为无人自动咖啡售卖机开发一个控制程序。  </p>
</li>
<li><p>用户可在咖啡机上进行支付、退款、购买、取咖啡操作</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724202535.png"></p>
<p><strong>咖啡机状态转换图</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724203116.png"></p>
<ul>
<li><p>不同的状态下，这四种种操作将有不同的表现。</p>
<p> 如在没有支付状态下，用户在咖啡机上点退款、购买、取咖啡，和在已支付的状态下做这三个操作。</p>
</li>
</ul>
<p> </p>
<h2 id="状态模式-代码示例"><a href="#状态模式-代码示例" class="headerlink" title="状态模式-代码示例"></a>状态模式-代码示例</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724203858.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724203924.png"></p>
<p>![image-20210724204001823](C:\Users\chen cheng\AppData\Roaming\Typora\typora-user-images\image-20210724204001823.png)</p>
<p>如何让状态可以灵活扩展（加状态）？</p>
<p>如何做到开闭原则？</p>
<h2 id="状态模式-类图"><a href="#状态模式-类图" class="headerlink" title="状态模式-类图"></a>状态模式-类图</h2><p>咖啡机的行为将委托给当前的状态实例</p>
<p> 状态可以灵活扩展否?</p>
<p>符合开闭原则否?</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724204708.png"></p>
<h2 id="状态模式-新代码示例"><a href="#状态模式-新代码示例" class="headerlink" title="状态模式-新代码示例"></a>状态模式-新代码示例</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724204836.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724204859.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724204939.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724205038.png"></p>
<h2 id="状态模式-命令模式-策略模式"><a href="#状态模式-命令模式-策略模式" class="headerlink" title="状态模式-命令模式-策略模式"></a>状态模式-命令模式-策略模式</h2><ul>
<li>策略模式侧重的是一个行为的多个算法实现，可互换算法。 </li>
<li>命令模式侧重的是为多个行为提供灵活的执行方式。</li>
<li>状态模式，应用于状态机的情况。</li>
</ul>
<p>设计原则∶区分变与不变，隔离变化</p>
<p>设计原则∶面向接口编程</p>
<p>设计原则∶多用组合，少用继承  </p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210720215841.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724200918.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724204708.png"></p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul>
<li><p><strong>示例：</strong>请开发一个画图程序，可以画各种颜色不同形状的图形，请用面向对象的思  想设计图形。</p>
</li>
<li><p><strong>分析：</strong></p>
<ol>
<li>比如有红、黄、蓝三种颜色</li>
<li>形状有方形、圆、三角形</li>
<li>圆可以是红圆、黄圆、蓝圆</li>
</ol>
<p><strong>这样设击类可否？加颜色、加形状，会类爆炸！</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724211541.png"></p>
</li>
<li><p>变化∶会从两个维度发生变化∶形状、颜色</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724211905.png"></p>
<p>任其在两个维度各自变化，为这两个维度搭个桥，让它们可以融合在一起∶桥接模式</p>
<p>如何搭?</p>
</li>
<li><p>1、抽象∶分别对各个维度进行抽象，将共同部分抽取出来<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724213204.png"></p>
</li>
<li><p>2、组合：将抽象组合在一起（桥接）<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724215059.png"></p>
</li>
</ul>
<p>桥接∶将多个维度的变化以抽象的方式组合在一起。使用者面向抽象。各维度间解耦，可自由变化。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li><p><strong>饥汉式【可用】</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>懒汉式</strong><br>懒汉式1【不可用】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式2【线程安全，但不推荐】<br>缺点：实例化后就不应该再同步了，效率低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式3【不可用】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式4 双重检查【推荐使用】<br>注意：volatile关键字修饰很关键<br>优点：线程安全；延迟加载；效率高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式5 静态内部类方式【推荐使用】<br>优点∶避免了线程不安全，延迟加载，效率高。<br> 原理∶静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式6 用枚举【推荐使用】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><ul>
<li><p><strong>示例：</strong>当我们设计—个类时，我们能明确它对外提供的某个方法的内部执行步骤但一些步骤，不同的子类有不同的行为时，我们该如何来设计该类? </p>
<p><strong>可以使用模板方法模式</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724221315.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724221341.png"></p>
</li>
<li><p><strong>优点：</strong><br>1、封装不变部分，扩展可变部分。<br>2、提取公共代码，便于维护。<br>3、行为由父类控制，子类实现。</p>
</li>
<li><p><strong>适用场景：</strong><br>1、有多个子类共有的方法，且逻辑相同。<br> 2、重要的、复杂的方法，可以考虑作为模板方法。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h2><table>
<thead>
<tr>
<th>序号</th>
<th>模式&amp;描述</th>
<th>包括</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>创建形模式</strong><br />这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
<td>工厂模式（Factory Pattern）<br />抽象工厂模式（Abstract Factory Pattern）<br />单例模式（Singleton Pattern）<br />建造者模式（Builder Pattern）<br />原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td>2</td>
<td><strong>结构型模式</strong><br />这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td>适配器模式（Adapter Pattern）<br />桥接模式（Bridge Patttern）<br />组合模式（Composite Patttern）<br />装饰器模式（Decorator Patttern）<br />外观模式（Facade Patttern）<br />享元模式（Flyweight Patttern）<br />代理模式（Proxy Patttern）</td>
</tr>
<tr>
<td>3</td>
<td><strong>行为型模式</strong><br />这些设计模式特别关注对象之间的通信。</td>
<td>责任链模式（Chain of Responsibility Pattern）<br />命令模式（Command Patttern）<br />解释器模式（Interpreter Patttern）<br />迭代器模式（Iterator Patttern）<br />中介者模式（Mediator Patttern）<br />备忘录模式（Memento Patttern）<br />观察者模式（Observer Patttern）<br />状态模式（State Patttern）<br />空对象模式（Null Object Patttern）<br />策略模式（Strategy Patttern）<br />模板模式（Template Patttern）<br />访问者模式（Visitor Patttern）</td>
</tr>
</tbody></table>
<h2 id="设计原则总结"><a href="#设计原则总结" class="headerlink" title="设计原则总结"></a>设计原则总结</h2><ul>
<li><p>找出变化，分开变化和不变的</p>
<p>隔离，封装变化的部分，让其他部分不受它的影响。 </p>
</li>
<li><p>面向接口编程（隔离变化的方式）</p>
<p>使用者使用接口，提供者实现接口。 “接口”可以是超类!</p>
</li>
<li><p>依赖倒置原则 （隔离变化的方式）</p>
<p>依赖抽象，不要依赖具体类!</p>
</li>
<li><p>对修改闭合，对扩展开放（隔离变化的方式）</p>
</li>
<li><p>多用组合，少用继承（ 灵活变化的方式）</p>
<p>“有一个”可能比”是一个”更好。</p>
</li>
<li><p>单一职责原则（方法设计的原则）</p>
</li>
<li><p><strong>最后，如果都忘记了，请一定要记住这三!!!</strong></p>
</li>
</ul>
<p>  </p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724223422.png"></p>
<h1 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h1><p><a target="_blank" rel="noopener" href="https://github.com/chengchen901/design-mode-study.git">https://github.com/chengchen901/design-mode-study.git</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/01-Java%E5%9F%BA%E7%A1%80/04-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="clmcxecrk006hu8wabbmt7lpx" data-title="设计模式（二）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-02-Spring/02-手写SpringIOC容器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/02-Spring/02-%E6%89%8B%E5%86%99SpringIOC%E5%AE%B9%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/02-Spring/02-%E6%89%8B%E5%86%99SpringIOC%E5%AE%B9%E5%99%A8/">手写SpringIOC容器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="IOC分析"><a href="#IOC分析" class="headerlink" title="IOC分析"></a>IOC分析</h1><ul>
<li><strong>IOC是什么?</strong><br><strong>IOC：Inversion of Control 控制反转，也称依赖倒置（反转 ）</strong><br>问题：如何理解控制反转？<br><strong>反转：依赖对象的获得被反转了。由自己创建，反转为从IOC容器中获取（和自动注入）</strong></li>
<li><strong>IOC容器做什么工作？</strong><br>IOC容器的工作：负责创建、管理类实例，向使用者提供实例。</li>
<li><strong>带来什么好处？</strong><ol>
<li>代码更简洁，不需要去new要使用的对象了。</li>
<li>面向接口编程，使用者与具体类解耦，易扩展、替换实现者。</li>
<li>可以方便进行AOP增强。</li>
</ol>
</li>
<li><strong>IOC容器是否是工厂模式的实例？</strong><br>是的。IOC容器负责来创建类实例对象，需要就从IOC容器中get。也称IOC容器为Bean工厂。IOC使用的是简单工厂模式。</li>
</ul>
<h1 id="IOC设计实现"><a href="#IOC设计实现" class="headerlink" title="IOC设计实现"></a>IOC设计实现</h1><h2 id="IOC容器设计-实现"><a href="#IOC容器设计-实现" class="headerlink" title="IOC容器设计&amp;实现"></a>IOC容器设计&amp;实现</h2><ul>
<li><p>Bean工厂怎么知道该如何创建bean？<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731132459.png"></p>
</li>
<li><p>如何告诉它?</p>
<p><strong>就是一个定义注册，我们可以给它定义一个定义注册接口</strong></p>
</li>
</ul>
<h2 id="Bean定义注册接口"><a href="#Bean定义注册接口" class="headerlink" title="Bean定义注册接口"></a>Bean定义注册接口</h2><ul>
<li><p>bean定义注册接口中应定义些什么方法？<br><strong>注册、获取bean定义…</strong></p>
</li>
<li><p>注册的bean定义信息如何区分？<br><strong>每个bean定义有一个唯一的名称</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731133030.png"></p>
<h2 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h2><ul>
<li><p>bean定义的用途是什么？<br><strong>告诉bean工厂该如何创建某类bean</strong></p>
</li>
<li><p>获得类的实例的方式有哪些？</p>
<ul>
<li><p>new 构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂方法</p>
<ul>
<li><p>静态的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Bean工厂帮我们创建bean时，它需要获知哪些信息？</p>
<ul>
<li><p>new 构造方法</p>
<p><strong>类名</strong></p>
</li>
<li><p>静态工厂方法</p>
<p><strong>工厂类名、工厂方法名（静态工厂创建不需要new创建对象，直接通过class调用方法即可）</strong></p>
</li>
<li><p>成员工厂方法</p>
<p><strong>工厂类名？工厂bean名（成员工厂也当做一个bean注册到bean工厂）</strong><br><strong>工厂方法名</strong></p>
</li>
</ul>
</li>
<li><p>每次从bean工厂获取bean实例时，是否都需要创建一个新的？</p>
<p><strong>否，有的只需单实例。</strong></p>
</li>
<li><p>bean定义是给bean工厂创建bean用的，那bean定义接口应向bean工厂提供哪些方法？</p>
<ul>
<li><strong>获取bean的类名：getBeanClass() :Class</strong></li>
<li><strong>获取工厂方法名：getFactoryMethodName():String</strong></li>
<li><strong>获取工厂bean名：getFactoryBeanName():String</strong></li>
<li><strong>是否是单例等方法：getScope():String isSingleton() isPrototype()</strong></li>
</ul>
</li>
<li><p>类对象交给IOC容器来管理， 类对象的生命周期中还可能有什么生命阶段事情要做吗？</p>
<ul>
<li><strong>比如创建对象后可能需要进行一些初始化</strong></li>
<li><strong>还有有些对象在销毁时可能要进行一些特定的销毁逻辑（如释放资源）</strong></li>
<li><strong>那就在Bean定义中提供让用户可指定初始化、销毁方法。</strong></li>
<li><strong>对Bean工厂就需提供 getInitMethodName() getDestroyMethodName()</strong></li>
</ul>
</li>
</ul>
<h2 id="Bean定义接口"><a href="#Bean定义接口" class="headerlink" title="Bean定义接口"></a>Bean定义接口</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731140444.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731140526.png"></p>
<p><strong>接口有了，来实现一个通用的bean定义GenericBeanDefinition</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731140614.png"></p>
<h2 id="IOC容器设计与实现"><a href="#IOC容器设计与实现" class="headerlink" title="IOC容器设计与实现"></a>IOC容器设计与实现</h2><ul>
<li>看看现在我们有些什么了…</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731140937.png"></p>
<h2 id="BeanFactory实现"><a href="#BeanFactory实现" class="headerlink" title="BeanFactory实现"></a>BeanFactory实现</h2><ul>
<li><p>来实现一个最基础的默认bean工厂： DefaultBeanFactory</p>
<ul>
<li><p>实现定义信息注册</p>
<ol>
<li><p>bean定义信息如何存放？<br><strong>Map</strong></p>
</li>
<li><p>bean定义是否可以重名？重名怎么办?</p>
<p><strong>我们是设计者，规则我们来定</strong></p>
</li>
</ol>
</li>
<li><p>实现bean工厂</p>
<ol>
<li><p>创建的bean用什么存放，方便下次获取?<br><strong>Map</strong></p>
</li>
<li><p>在getBean方法中要做哪些事？</p>
<p><strong>创建bean实例，进行初始化</strong></p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="扩展DefaultBeanFactory"><a href="#扩展DefaultBeanFactory" class="headerlink" title="扩展DefaultBeanFactory"></a>扩展DefaultBeanFactory</h2><ul>
<li>思考：对于单例bean，我们可否提前实例化？这样有什么好处？</li>
<li>增加提前实例化单例Bean的功能</li>
</ul>
<p><strong>实现提前实例化单例Bean</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731142025.png"></p>
<h1 id="DI分析"><a href="#DI分析" class="headerlink" title="DI分析"></a>DI分析</h1><h2 id="DI-Dependency-injection-依赖注入-分析"><a href="#DI-Dependency-injection-依赖注入-分析" class="headerlink" title="DI(Dependency injection)依赖注入-分析"></a>DI(Dependency injection)依赖注入-分析</h2><ul>
<li>哪些地方会有依赖？<ul>
<li><strong>构造参数依赖</strong></li>
<li><strong>属性依赖</strong></li>
</ul>
</li>
<li>依赖注入的本质是什么？<ul>
<li><strong>给值：给入构造参数值，给属性赋值</strong></li>
</ul>
</li>
<li>参数值、属性值可能是什么值？<ul>
<li><strong>直接值、bean依赖</strong></li>
</ul>
</li>
<li>值会有哪几种情形？<ul>
<li><strong>基本数据类型值、String</strong></li>
<li><strong>数组、集合</strong></li>
<li><strong>Properties</strong></li>
<li><strong>map</strong></li>
</ul>
</li>
</ul>
<p><strong>本质：参数值、属性值，都是值。bean工厂在进行依赖注入时，就是给入值。</strong></p>
<p>如何告诉bean工厂该给入什么构造参数值？即如何来定义参数依赖？</p>
<p>如何来定义属性依赖？</p>
<h1 id="DI实现"><a href="#DI实现" class="headerlink" title="DI实现"></a>DI实现</h1><h2 id="DI依赖注入-构造参数依赖定义分析"><a href="#DI依赖注入-构造参数依赖定义分析" class="headerlink" title="DI依赖注入-构造参数依赖定义分析"></a>DI依赖注入-构造参数依赖定义分析</h2><p><strong>如何定义构造参数依赖？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(String name,<span class="type">int</span> age,<span class="type">char</span> cup,Boy boyfriend)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们要创建一个Girl是如何创建的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boy</span> <span class="variable">lad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="string">&quot;prettyBoy&quot;</span>);</span><br><span class="line"><span class="type">Girl</span> <span class="variable">beautGirl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;小丽&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;D&#x27;</span>,lad);</span><br></pre></td></tr></table></figure>

<p>直接把值就给它了，就这么简单! </p>
</li>
<li><p>那我们可不可以这样来定义构造参数依赖？</p>
<ul>
<li><strong>第一个参数值是： “小丽”</strong></li>
<li><strong>第二个参数值是：18</strong></li>
<li><strong>第三个参数值是： ‘D’</strong></li>
<li><strong>第四个参数值是：依赖一个Boy Bean</strong></li>
</ul>
</li>
</ul>
<h2 id="DI-构造参数依赖设计"><a href="#DI-构造参数依赖设计" class="headerlink" title="DI-构造参数依赖设计"></a>DI-构造参数依赖设计</h2><ul>
<li><p>参数可以多个，用什么存储？<br><strong>集合：List</strong></p>
</li>
<li><p>参数有顺序，如何体现顺序？<br><strong>按参数顺序放入List</strong></p>
</li>
<li><p>参数值可以是直接值，也可以是bean依赖，如何表示：Object?</p>
<p><strong>可以，也只能用Object了。</strong><br><strong>List<Object> constructorArgumentValues</strong></p>
</li>
<li><p>如果用Object来表示值，如何区分是Bean依赖？<br><strong>为Bean依赖定义一种数据类型（BeanReference），bean工厂在构造Bean实例时，遍历判断参数是否是BeanReference，如是则替换为依赖的bean实例。</strong></p>
</li>
<li><p>如果直接值是数组、集合等，它们的元素中有的是bean依赖，怎么处理？<br><strong>元素值还是用BeanReference，同样bean工厂在使用时需遍历替换。</strong></p>
</li>
</ul>
<h2 id="DI实现-BeanReference"><a href="#DI实现-BeanReference" class="headerlink" title="DI实现-BeanReference"></a>DI实现-BeanReference</h2><ul>
<li>BeanReference就是用来说明bean依赖的：依赖哪个Bean</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731175542.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731175652.png"></p>
<h2 id="DI实现-构造参数依赖定义"><a href="#DI实现-构造参数依赖定义" class="headerlink" title="DI实现-构造参数依赖定义"></a>DI实现-构造参数依赖定义</h2><ul>
<li>在BeanDefinition中增加获得构造参数值的接口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731180013.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setConstructorArgumentValues</span><span class="params">(List&lt;?&gt; constructorArgumentValues)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;?&gt; getConstructorArgumentValues();</span><br></pre></td></tr></table></figure>

<ul>
<li>在GenericBeanDefinition中增加对应的实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;?&gt; constructorArgumentValues;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConstructorArgumentValues</span><span class="params">(List&lt;?&gt; constructorArgumentValues)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.constructorArgumentValues = constructorArgumentValues;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;?&gt; getConstructorArgumentValues() &#123;</span><br><span class="line">	<span class="keyword">return</span> constructorArgumentValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DI实现-BeanFactory中实现构造参数依赖注入"><a href="#DI实现-BeanFactory中实现构造参数依赖注入" class="headerlink" title="DI实现-BeanFactory中实现构造参数依赖注入"></a>DI实现-BeanFactory中实现构造参数依赖注入</h2><ul>
<li>首先需要把bean定义中的构造参数引用转为真实的值，在DefaultBeanFactory中增加一个方法来干这事。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731180558.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] getConstructorArgumentValues(BeanDefinition beanDefinition) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;?&gt; args = beanDefinition.getConstructorArgumentValues();</span><br><span class="line">    <span class="keyword">return</span> getRealValues(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数值解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] getRealValues(List&lt;?&gt; args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(args)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object[] values = <span class="keyword">new</span> <span class="title class_">Object</span>[args.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.size(); i++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rv</span> <span class="operator">=</span> args.get(i);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (rv == <span class="literal">null</span>) &#123;</span><br><span class="line">            v = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv <span class="keyword">instanceof</span> BeanReference) &#123;</span><br><span class="line">            v = <span class="built_in">this</span>.doGetBean(((BeanReference) rv).getBeanName());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">            <span class="comment">// TODO 处理集合中的bean引用</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">            <span class="comment">// TODO 处理集合中的bean引用</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv <span class="keyword">instanceof</span> Properties) &#123;</span><br><span class="line">            <span class="comment">// TODO 处理properties中的bean引用</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            <span class="comment">// TODO 处理Map中的bean引用</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v = rv;</span><br><span class="line">        &#125;</span><br><span class="line">        values[i] = v;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>有参数了，如何断定是哪个构造方法、哪个工厂方法？</p>
<ol>
<li><p>方法是可以重载的</p>
</li>
<li><p>形参定义时可能是接口或父类，实参则是具体的子实现</p>
</li>
<li><p>反射提供的获取的构造方法、方法的API，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;T&gt; <span class="title function_">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span>;</span><br><span class="line">Constructor&lt;?&gt;[] getConstructors();</span><br><span class="line"></span><br><span class="line">Method <span class="title function_">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span>;</span><br><span class="line">Method[] getMethods();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>判断逻辑：</p>
<ol>
<li>先根据参数的类型进行精确匹配查找，如未找到，则进行第2步查找；</li>
<li>获得所有的构造方法，遍历，通过参数数量过滤，再比对形参类型与实参类型。</li>
</ol>
</li>
<li><p>当我们判断出构造方法或工厂方法后，对于原型Bean,下次获取Bean是否就可以省去判断了？<br><strong>也就是说，对于原型bean，我们可以缓存下这个构造方法或工厂方法。如何实现？</strong><br><strong>在BeanDefinition中增加缓存的方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setConstructor</span><span class="params">(Constructor&lt;?&gt; constructor)</span>;</span><br><span class="line">  </span><br><span class="line">Constructor&lt;?&gt; getConstructor();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setFactoryMethod</span><span class="params">(Method method)</span>;</span><br><span class="line">  </span><br><span class="line">Method <span class="title function_">getFactoryMethod</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>在GenericBeanDefinition中增加对应的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Constructor&lt;?&gt; constructor;</span><br><span class="line">   <span class="keyword">private</span> Method method;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConstructor</span><span class="params">(Constructor&lt;?&gt; constructor)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.constructor = constructor;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Constructor&lt;?&gt; getConstructor() &#123;</span><br><span class="line">       <span class="keyword">return</span> constructor;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactoryMethod</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.method = method;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Method <span class="title function_">getFactoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> method;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在DefaultBeanFactory中增加查找构造方法的方法<br>看代码：private Constructor&lt;?&gt; determineConstructor(BeanDefinition bd, Object[] args)</p>
</li>
<li><p>修改DefaultBeanFactory中用构造方法方式创建实例的方法代码<br>看代码：private Object createBeanByConstructor(BeanDefinition bd)</p>
</li>
<li><p>依照上面的方式修改静态工厂方法、工厂方法方式的参数依赖<br>看代码：Method determineFactoryMethod(BeanDefinition bd, Object[] args, Class&lt;?&gt; type)<br>private Object createBeanByStaticFactory(BeanDefinition bd) </p>
<p>private Object createBeanByBeanFactory(BeanDefinition bd) </p>
</li>
<li><p>循环依赖如何处理？</p>
<ul>
<li>构造对象时可以循环依赖吗？</li>
<li>构造实例对象时的循环依赖，会陷入僵死局面，是不允许构造实例时的循环依赖的。如何发现循环依赖？</li>
<li><strong>方式：加入一个正在构造的bean的记录，每个bean开始构造时加入到该记录中，构造完成后从记录中移除。如果有依赖，先看依赖的bean是否在构造中，如是就构成了循环依赖，抛出异常。</strong></li>
</ul>
</li>
</ul>
<h2 id="DI实现-属性依赖设计-实现"><a href="#DI实现-属性依赖设计-实现" class="headerlink" title="DI实现-属性依赖设计&amp;实现"></a>DI实现-属性依赖设计&amp;实现</h2><p><strong>属性依赖</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> cup;</span><br><span class="line">    <span class="keyword">private</span> Boy boyfriend;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>属性依赖是什么？<br><strong>某个属性依赖某个值</strong></p>
</li>
<li><p>该如何来描述一个属性依赖？<br><strong>属性名、值，定义一个类来表示这两个值</strong></p>
</li>
<li><p>会有多个属性依赖，怎么存放？<br><strong>List</strong></p>
</li>
<li><p>属性值的情况和构造参数值一样吗？<br><strong>一样的</strong></p>
</li>
<li><p>定义属性依赖描述实体类PropertyValue</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210731212055.png"></p>
<ul>
<li><p>在BeanDefinition中增加获得属性依赖定义的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setPropertyValues</span><span class="params">(List&lt;PropertyValue&gt; propertyValues)</span>;</span><br><span class="line">  </span><br><span class="line">List&lt;PropertyValue&gt; <span class="title function_">getPropertyValues</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>在GenericBeanDefinition中增加对应的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> List&lt;PropertyValue&gt; propertyValues;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPropertyValues</span><span class="params">(List&lt;PropertyValue&gt; propertyValues)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.propertyValues = propertyValues;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;PropertyValue&gt; <span class="title function_">getPropertyValues</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> propertyValues;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在DefaultBeanFactory中实现属性依赖<br>看代码： private void setPropertyDIValues(BeanDefinition bd, Object instance)<br>在doGetBean(String beanName)中增加对设置属性依赖的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建好实例后，移除创建中记录</span></span><br><span class="line">ingBeans.remove(beanName);</span><br><span class="line"><span class="comment">// 给入属性依赖</span></span><br><span class="line"><span class="built_in">this</span>.setPropertyDIValues(bd, instance);</span><br><span class="line"><span class="comment">// 执行初始化方法</span></span><br><span class="line"><span class="built_in">this</span>.doInit(bd, instance);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="拓展—加需求"><a href="#拓展—加需求" class="headerlink" title="拓展—加需求"></a>拓展—加需求</h1><ul>
<li><p>Bean增加别名支持</p>
<p>Bean除了标识唯一的名称外，还可以有任意个别名，别名也是唯一的。</p>
</li>
<li><p>beanFactory增加可按Class来获取Bean对象的功能</p>
</li>
<li><p>加入配置参数加载、注入给Bean的功能</p>
</li>
<li><p>加入Bean配置的条件依赖生效支持</p>
<p>在bean定义配置中可以指定它条件依赖某些bean或类，当这些bean和类存在时，这个bean配置才有效。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/02-Spring/02-%E6%89%8B%E5%86%99SpringIOC%E5%AE%B9%E5%99%A8/" data-id="clmcxecs7006mu8wagi097287" data-title="手写SpringIOC容器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-02-Spring/03-手写SpringAOP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/02-Spring/03-%E6%89%8B%E5%86%99SpringAOP/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/02-Spring/03-%E6%89%8B%E5%86%99SpringAOP/">手写SpringAOP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="AOP分析"><a href="#AOP分析" class="headerlink" title="AOP分析"></a>AOP分析</h1><h2 id="AOP框架的责任"><a href="#AOP框架的责任" class="headerlink" title="AOP框架的责任"></a>AOP框架的责任</h2><ul>
<li><p><strong>AOP是什么？</strong></p>
<p>Aspect Oriented Programming面向切面编程，在不改变类的代码的情况下，对类方法进行功能增强。</p>
</li>
<li><p><strong>AspectJ和AOP的代理区别？</strong></p>
<p>AspectJ会对原有的类的二进制文件进行修改，当你在类的内部调用其它方法时还是会功能增强。</p>
<p>AOP是基于动态代理，在不改变类的代码的情况下，对类方法进行功能增强。所以当你在类的内部调用其它方法时没有通过代理类是不会功能增强。</p>
</li>
<li><p><strong>AOP框架要做什么？</strong></p>
<p>AOP框架中要向使用用户提供AOP功能，让用户可以通过AOP技术实现对类方法进行功能增强。</p>
</li>
</ul>
<h2 id="AOP元素分析"><a href="#AOP元素分析" class="headerlink" title="AOP元素分析"></a>AOP元素分析</h2><p><strong>Advice</strong></p>
<p>​	通知，增强的功能（用户提供框架使用）</p>
<p><strong>Join points</strong></p>
<p>​	连接点，可选的方法点（框架提供用户使用）</p>
<p><strong>Pointcut</strong></p>
<p>​	切入点，选择切入的方法点（用户提供框架使用）</p>
<p><strong>Aspect</strong></p>
<p>​	切面，选择的（多个）方法点  + 增强的功能（用户提供框架使用）</p>
<p><strong>Introduction</strong></p>
<p>​	引入 ：添加新的方法、属性到已存在的类中，就叫引入</p>
<p><strong>Weaving</strong></p>
<p>​	织入（编织）：不改原类的代码，加入功能增强（框架使用）</p>
<h2 id="AOP分析-1"><a href="#AOP分析-1" class="headerlink" title="AOP分析"></a>AOP分析</h2><p>Aspect Oriented Programming面向切面编程，在不改变类的代码的情况下，对类方法进行功能增强。</p>
<p>根据AOP的定义，得出AOP需要提供的功能特性</p>
<h2 id="图解AOP"><a href="#图解AOP" class="headerlink" title="图解AOP"></a>图解AOP</h2><p>AOP各个元素参与AOP执行流程示意理解图</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210802223915.png"></p>
<h2 id="AOP概念—特点分析"><a href="#AOP概念—特点分析" class="headerlink" title="AOP概念—特点分析"></a>AOP概念—特点分析</h2><p>Advice、Pointcut、Weaving各自有什么特点？</p>
<ul>
<li><p><strong>Advice</strong></p>
<ol>
<li>用户性：由用户提供增强功能逻辑代码</li>
<li>变化的：不同的增强需求，会有不同的逻辑</li>
<li>可选时机：可选择在方法功能前、后、异常时进行功能增强</li>
<li>多重的：同一个切入点上可以有多重增强</li>
</ol>
</li>
<li><p><strong>Pointcut</strong></p>
<ol>
<li>用户性：由用户来指定</li>
<li>变化的：用户可灵活指定</li>
<li>多点性：用户可以选择在多个点上进行增强</li>
</ol>
</li>
<li><p><strong>Weaving</strong></p>
<ol>
<li>无侵入性，不改原类代码</li>
<li>在AOP框架中实现</li>
</ol>
</li>
</ul>
<h1 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h1><h2 id="Advice设计"><a href="#Advice设计" class="headerlink" title="Advice设计"></a>Advice设计</h2><ul>
<li>Advice是由用户来提供，我们来使用，它是多变的。<ol>
<li>我们如何能认识用户提供的东西？用户在我们写好框架后使用我们的框架。</li>
<li>如何让我们的代码隔绝用户提供的多变？</li>
</ol>
</li>
</ul>
<p><strong>我们定义一套标准接口，用户通过实现接口来提供他们不同的逻辑。</strong></p>
<p><strong>重要设计原则：如何应对变化，面向接口编程！</strong></p>
<ul>
<li><p>定义Advice接口</p>
<p>接口没有定义任何方法</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210802225142.png"></p>
</li>
<li><p>Advice的特点：可选时机，可选择在方法功能前、后、异常时进行功能增强</p>
<ol>
<li>有的advice是在方法执行前进行增强；（前置增强）</li>
<li>有的是在方法执行后进行增强；（后置增强）</li>
<li>有的会是之前、之后都进行增强；（环绕增强）</li>
<li>有的则只是在方法执行抛出异常时进行异常增强处理；（异常处理增强）</li>
</ol>
</li>
</ul>
<p>我们需要做什么？</p>
<p>​	定义标准接口方法，让用户可以实现它，提供各种增强。</p>
<h2 id="Advice—前置增强分析"><a href="#Advice—前置增强分析" class="headerlink" title="Advice—前置增强分析"></a>Advice—前置增强分析</h2><ul>
<li><p>前置增强：在方法执行前进行增强。</p>
<ul>
<li><p>它可能需要什么参数？</p>
<p>目的是对方法进行增强，应该需要的是方法相关的信息；我们使用它时，能给入它的好像也只有当前要执行方法的信息。</p>
</li>
<li><p>运行时方法有哪些信息？</p>
<ul>
<li>方法本身 Method</li>
<li>方法所属的对象 Object </li>
<li>方法的参数 Object[]</li>
</ul>
</li>
<li><p>前置增强的返回值是什么？</p>
<ul>
<li>在方法执行前进行增强，不需要返回值！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Advice—后置增强分析"><a href="#Advice—后置增强分析" class="headerlink" title="Advice—后置增强分析"></a>Advice—后置增强分析</h2><ul>
<li>后置增强：在方法执行后进行增强<ul>
<li>它可能需要什么参数？<ul>
<li>方法本身 Method</li>
<li>方法所属的对象 Object </li>
<li>方法的参数 Object[]</li>
<li>方法的返回值 Object</li>
</ul>
</li>
<li>它的返回值是什么？<ul>
<li>在方法执行后进行增强，不需要返回值！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Advice—环绕增强分析"><a href="#Advice—环绕增强分析" class="headerlink" title="Advice—环绕增强分析"></a>Advice—环绕增强分析</h2><ul>
<li>环绕增强：包裹方法进行增强<ul>
<li>它可能需要什么参数？<ul>
<li>方法本身 Method</li>
<li>方法所属的对象 Object </li>
<li>方法的参数 Object[]</li>
</ul>
</li>
<li>它的返回值是什么？<ul>
<li>方法被它包裹，也即方法的将由它来执行，它需要返回方法的返回值。 Object</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Advice—异常处理增强分析"><a href="#Advice—异常处理增强分析" class="headerlink" title="Advice—异常处理增强分析"></a>Advice—异常处理增强分析</h2><ul>
<li><p>异常处理增强：捕获方法执行时的异常，进行增强处理</p>
<ul>
<li><p>进行异常处理增强需要包裹方法吗？</p>
<p>需要</p>
</li>
<li><p>那它可否在环绕中实现？</p>
<p>可以</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	...执行方法</span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionA e)&#123;</span><br><span class="line">	...A异常的增强处理</span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionB e)&#123;</span><br><span class="line">	...B异常的增强处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Advice设计-1"><a href="#Advice设计-1" class="headerlink" title="Advice设计"></a>Advice设计</h2><ul>
<li><p>经前面的分析，我们一共需要定义三个方法</p>
<p>思考：是把这三个定义到一个接口中，还是分三个接口定义？</p>
<p><strong>分三个接口，还可通过类型来区分不同的Advice</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210802231203.png"></p>
<h1 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h1><h2 id="Pointcut分析"><a href="#Pointcut分析" class="headerlink" title="Pointcut分析"></a>Pointcut分析</h2><ul>
<li><p>Pointcut的特点</p>
<ol>
<li>用户性：由用户来指定</li>
<li>变化的：用户可灵活指定</li>
<li>多点性：用户可以选择在多个点上进行增强</li>
</ol>
</li>
<li><p>我们需要做什么？</p>
<p>为用户提供一个东西，让他们可以灵活地指定多个方法点，而我们又能懂！</p>
<p>思考：切入点是由用户来指定在哪些方法点上进行增强，那么这个哪些方法点如何来表示，能满足上面的特点？</p>
</li>
<li><p>分析</p>
<ol>
<li><p>指定哪些方法，是不是一个描述信息？</p>
</li>
<li><p>如何来指定一个方法？（xx类的xx方法）</p>
</li>
<li><p>重载怎么办？（加上参数类型）</p>
</li>
<li><p>总结：其实就是一个完整的方法签名！</p>
<p>com.study.spring.aop.Girl.dbj(Boy,Time)</p>
<p>com.study.spring.aop.Girl.dbj(Boy,Girl,Time)</p>
</li>
<li><p>如何做到多点性，灵活性？在一个描述中指定一类方法？</p>
<ul>
<li><p>某个包下的某个类的某个方法</p>
</li>
<li><p>某个包下的所有类中所有方法</p>
</li>
<li><p>某个包下的所有类中的do开头的方法</p>
</li>
<li><p>某个包下的以service结尾的类的中的do开头的方法</p>
</li>
<li><p>某个包下的及其子包下的以service结尾的类的中的do开头的方法</p>
<p>我们需要一个表达式，能灵活描述这些的信息的表达式</p>
</li>
</ul>
</li>
<li><p>要表达哪些信息？</p>
<p>包名.类名.方法名(参数类型)</p>
</li>
<li><p>每部分的要求是怎样的？</p>
<ul>
<li>包名：有父子特点，要能模糊匹配</li>
<li>类名：要能模糊匹配</li>
<li>方法：要能模糊匹配</li>
<li>参数类型：参数可以多个</li>
</ul>
</li>
<li><p>这个表达式将被我们用来决定是否需要对某个类的某方法进行增强，这个决定过程应该是怎样的？</p>
<ul>
<li>匹配类，匹配方法</li>
</ul>
</li>
<li><p>一个表达式如果不好实现，分成多个表达式进行组合是否容易些？</p>
<ul>
<li><strong>是的，可以这么考虑！</strong></li>
</ul>
</li>
<li><p>我们的掌握的表达式有哪些？它们是否能满足这里的需要？</p>
<ul>
<li><strong>正则表达式？</strong></li>
<li><strong>Ant Path表达式？</strong></li>
<li><strong>AspectJ 的 pointcut 表达式?</strong>           execution(* com.xyz.service.AccountService.*(..))</li>
</ul>
<p><strong>正则表达式是可以的。AspectJ本就是切面编程组件，也是可以的。</strong></p>
<p>AspectJ官网地址：<a target="_blank" rel="noopener" href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a></p>
</li>
</ol>
</li>
</ul>
<h2 id="AspectJ表达式语法学习"><a href="#AspectJ表达式语法学习" class="headerlink" title="AspectJ表达式语法学习"></a>AspectJ表达式语法学习</h2><ul>
<li><p>通过spring中的AOP介绍学习：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts</a></p>
</li>
<li><p>如果英文有问题，请参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/loongss/p/5774859.html">https://www.cnblogs.com/loongss/p/5774859.html</a></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</span><br></pre></td></tr></table></figure>

<h2 id="Pointcut设计"><a href="#Pointcut设计" class="headerlink" title="Pointcut设计"></a>Pointcut设计</h2><ul>
<li><p>该来对Pointcut进行接口、类设计了</p>
<ol>
<li><p>切点应有什么属性？</p>
<p>切点定义表达式</p>
</li>
<li><p>切点应对外提供什么行为（方法）？<br>检验类是否匹配<br>检验方法是否匹配</p>
</li>
<li><p>切点将被我们用来做什么？<br>对类、方法进行匹配<br>切点应提供匹配类，匹配方法的行为。</p>
</li>
<li><p>如果在我们设计的框架中要能灵活扩展切点的实现方式，我们该如何设计？<br>这又是一个要支持可多变的问题，像通知一样，我们来定义一套标准接口，定义好基本行为，面向接口编程，屏蔽掉具体的实现。<br>无论哪种实现，都实现匹配类、匹配方法的接口</p>
</li>
</ol>
</li>
<li><p>Pointcut标准接口</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210803001459.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.aop.pointcut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matchsClass</span><span class="params">(Class&lt;?&gt; targetClass)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matchsMethod</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AspectJExpressionPointcut实现"><a href="#AspectJExpressionPointcut实现" class="headerlink" title="AspectJExpressionPointcut实现"></a>AspectJExpressionPointcut实现</h2></li>
<li><p>实现步骤</p>
<ol>
<li><p>引入AspectJ的jar</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>掌握Aspectj的api使用，我们只使用它的切点表达式解析匹配部分。</p>
<ol>
<li><p>入口：org.aspectj.weaver.tools.PointcutParser 获得切点解析器；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PointcutParser</span> <span class="variable">pp</span> <span class="operator">=</span> PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析表达式，得到 org.aspectj.weaver.tools.PointcutExpression</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PointcutExpression</span> <span class="variable">pe</span> <span class="operator">=</span> pp.parsePointcutExpression(</span><br><span class="line">                <span class="string">&quot;execution(* com.study.beans.BeanFactory.get*(..))&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>用PointcutExpression 匹配类，不可靠。没关系，通过方法匹配来正确匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pe.couldMatchJoinPointsInType(ABean.class)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用PointcutExpression 匹配方法，可靠。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cl = ABean.class;</span><br><span class="line"><span class="type">Method</span> <span class="variable">aMethod</span> <span class="operator">=</span> cl.getMethod(<span class="string">&quot;doSomthing&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">ShadowMatch</span> <span class="variable">sm</span> <span class="operator">=</span> pe.matchesMethodExecution(aMethod);</span><br><span class="line">System.out.println(sm.alwaysMatches());</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="Advice-Pointcut使用"><a href="#Advice-Pointcut使用" class="headerlink" title="Advice Pointcut使用"></a>Advice Pointcut使用</h2><ul>
<li>用户该如何使用我们提供的东西？<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210803001946.png"></li>
</ul>
<h2 id="Aspec设计"><a href="#Aspec设计" class="headerlink" title="Aspec设计"></a>Aspec设计</h2><ul>
<li>为用户提供更简单的外观，Advisor(通知者)组合Advice和Pointcut</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210803003340.png"></p>
<h2 id="Advisor扩展说明"><a href="#Advisor扩展说明" class="headerlink" title="Advisor扩展说明"></a>Advisor扩展说明</h2><ul>
<li>扩展不同的Advisor实现<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210803003602.png"></li>
<li>还可这样设计<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210803003817.png"></li>
</ul>
<h1 id="Weaving"><a href="#Weaving" class="headerlink" title="Weaving"></a>Weaving</h1><h2 id="Weaving-织入-分析"><a href="#Weaving-织入-分析" class="headerlink" title="Weaving 织入-分析"></a>Weaving 织入-分析</h2><ul>
<li><p>织入要完成什么？</p>
<p>将用户提供的增强功能加到指定的方法上。这部分是要我们实现的！</p>
</li>
<li><p>请思考以下问题：</p>
<ol>
<li><p>在什么时候做织入？</p>
<p>创建bean实例的时候，在bean初始化后，再对其进行增强。</p>
</li>
<li><p>如何确定bean要增强？</p>
<p>对bean类及方法挨个匹配用户指定的切面，如果有匹配的切面就是要增强。</p>
</li>
<li><p>如何织入？</p>
<p>代理</p>
</li>
</ol>
</li>
</ul>
<h2 id="Weaving-织入-设计"><a href="#Weaving-织入-设计" class="headerlink" title="Weaving 织入-设计"></a>Weaving 织入-设计</h2><ul>
<li>整理一下AOP的使用流程，帮助我们更好地去设计织入</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210804205856.png"></p>
<ul>
<li><p>思考：</p>
<ol>
<li><p>用户到哪里去注册切面？</p>
<p>BeanFactory？</p>
</li>
<li><p>判断匹配、织入的逻辑写到哪里？</p>
<p>写在BeanFactory中？</p>
</li>
<li><p>我们现在是不是要在Bean创建的过程中加一项处理？</p>
</li>
<li><p>后续可能在bean创建过程中还会加入更多别的处理，如果直接在BeanFactory中实现会有什么不好？</p>
<ul>
<li>BeanFactory类代码爆炸</li>
<li>不易扩展</li>
</ul>
</li>
</ol>
</li>
<li><p>回顾总结一下Bean的产生过程都经历了什么</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210804210418.png"></p>
<p>在这个过程中，将来会有更多处理逻辑加入到过程的不同阶段</p>
<p>我们如何设计能让我们一次写好BeanFactory后，不改代码，就可以灵活扩展！</p>
<p>在各个节点加入扩展点，加入注册机制。</p>
<p>什么是扩展点，什么是注册机制？</p>
<p>​	想想观察者模式（监听模式）</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210724182323.png"></p>
<p>这里有六个扩展点，就是六个主题，六类观察者。</p>
<p>该设计几个接口？</p>
<p>​	由你来定了！</p>
<ul>
<li>应用观察者模式来加入我们的AOP织入</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210804211351.png"></p>
<h2 id="Weaving-织入-实现"><a href="#Weaving-织入-实现" class="headerlink" title="Weaving 织入-实现"></a>Weaving 织入-实现</h2><ul>
<li>现在来聚焦实现织入：判断bean是否需要织入增强</li>
</ul>
<p>如何判断bean实例是否要增强？</p>
<ol>
<li><p>获取bean的类及所有方法；</p>
<p>如何取到所有的方法？<br>这两个方法可以取到吗？可以使用spring-core中的工具类获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前类和父类中的所有public方法</span></span><br><span class="line">Method[] getMethods();</span><br><span class="line"><span class="comment">// 获取当前类所有的public、default、properted、private方法</span></span><br><span class="line">Method[] getDeclaredMethods();</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历Advisor，取advisor中的Pointcut来匹配类、方法。</p>
</li>
</ol>
<p>![image-20210804213839940](C:\Users\chen cheng\AppData\Roaming\Typora\typora-user-images\image-20210804213839940.png)</p>
<ul>
<li>现在来聚焦实现织入：代理增强</li>
</ul>
<p>代理增强的逻辑是怎样？</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210804214530.png"></p>
<h2 id="回顾-JDK状态代理"><a href="#回顾-JDK状态代理" class="headerlink" title="回顾-JDK状态代理"></a>回顾-JDK状态代理</h2><ul>
<li>在运行时，对接口创建代理对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210804215507.png"></p>
<h2 id="回顾-CGLIB动态代理"><a href="#回顾-CGLIB动态代理" class="headerlink" title="回顾-CGLIB动态代理"></a>回顾-CGLIB动态代理</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210804215658.png"></p>
<h2 id="Weaving-织入-搭架子"><a href="#Weaving-织入-搭架子" class="headerlink" title="Weaving 织入- 搭架子"></a>Weaving 织入- 搭架子</h2><ul>
<li>先把架子搭起来，再填砖！</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210807215058.png"></p>
<h2 id="Weaving-织入-增强逻辑实现"><a href="#Weaving-织入-增强逻辑实现" class="headerlink" title="Weaving 织入- 增强逻辑实现"></a>Weaving 织入- 增强逻辑实现</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210807215808.png"></p>
<p>它们俩中的逻辑一样吗？</p>
<p>都是应用Advice增强具体的逻辑是怎样的？</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210807220539.png"></p>
<p><strong>把相同的处理逻辑提出来</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210807215914.png"></p>
<h2 id="Weaving-织入-代理创建实现"><a href="#Weaving-织入-代理创建实现" class="headerlink" title="Weaving 织入- 代理创建实现"></a>Weaving 织入- 代理创建实现</h2><ul>
<li>实现代理对象创建</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210807220930.png"></p>
<ol>
<li>先实现jdk方式的，需要的参数：<ul>
<li>要实现的接口</li>
<li>InvocationHandler</li>
</ul>
</li>
<li>实现Cglib方式的：需要的参数<ul>
<li>继承的类</li>
<li>实现的接口</li>
<li>Callback</li>
<li>构造参数类型</li>
<li>构造参数</li>
</ul>
</li>
</ol>
<p>问题：构造参数类型、构造参数从哪来？</p>
<p>创建对象实例时会有！</p>
<h2 id="Weaving-织入-传递构造参数、参数类型"><a href="#Weaving-织入-传递构造参数、参数类型" class="headerlink" title="Weaving 织入- 传递构造参数、参数类型"></a>Weaving 织入- 传递构造参数、参数类型</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210807221743.png"></p>
<p>如何来传递创建bean实例时获得的数据到初始化后的Aop中？</p>
<p>这里我们要考虑BeanFactory的IOC&amp;DI纯洁性，不应与其他功能的类有染！</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210807222819.png"></p>
<p>方式：<strong>在BeanDefinition中用ThreadLocal持有参数值</strong></p>
<h2 id="Weaving-织入-如何使用AopProxy"><a href="#Weaving-织入-如何使用AopProxy" class="headerlink" title="Weaving 织入- 如何使用AopProxy"></a>Weaving 织入- 如何使用AopProxy</h2><ul>
<li>Creator中怎么使用AopProxy?</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210807223607.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210807223837.png"></p>
<p>怎么使用AopProxy？</p>
<p>应用一下工厂模式吧！把选择的逻辑交给工厂</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210807224058.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/02-Spring/03-%E6%89%8B%E5%86%99SpringAOP/" data-id="clmcxecse006pu8wadg4m9s46" data-title="手写SpringAOP" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-02-Spring/04-手写Spring配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/02-Spring/04-%E6%89%8B%E5%86%99Spring%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/02-Spring/04-%E6%89%8B%E5%86%99Spring%E9%85%8D%E7%BD%AE/">手写Spring配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="配置分析"><a href="#配置分析" class="headerlink" title="配置分析"></a>配置分析</h1><h2 id="为什么要提供配置的方式？"><a href="#为什么要提供配置的方式？" class="headerlink" title="为什么要提供配置的方式？"></a>为什么要提供配置的方式？</h2><p><strong>框架为什么提供配置方式？</strong></p>
<ol>
<li>实用简单、改动灵活</li>
<li>不需要改动代码</li>
</ol>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210810215118.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210810214907.png"></p>
<h2 id="配置方式的工作过程"><a href="#配置方式的工作过程" class="headerlink" title="配置方式的工作过程"></a>配置方式的工作过程</h2><p>能用什么样的配置方式？</p>
<p>XML和注解</p>
<p>各自的配置方式工作过程如图：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210810220201.png"></p>
<h1 id="配置工作过程"><a href="#配置工作过程" class="headerlink" title="配置工作过程"></a>配置工作过程</h1><h2 id="定义xml标记、注解"><a href="#定义xml标记、注解" class="headerlink" title="定义xml标记、注解"></a>定义xml标记、注解</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210810221020.png"></p>
<h2 id="Bean定义需要指定哪些信息？"><a href="#Bean定义需要指定哪些信息？" class="headerlink" title="Bean定义需要指定哪些信息？"></a>Bean定义需要指定哪些信息？</h2><p><strong>BeanDefinition接口告诉我们相关信息</strong></p>
<p>![image-20210810221249952](C:\Users\chen cheng\AppData\Roaming\Typora\typora-user-images\image-20210810221249952.png)</p>
<p>Xml需要哪些标记信息？</p>
<p>我们需要为此定义一个DTD或者XSD文档</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210810214907.png"></p>
<p>需要定义些什么注解？</p>
<p>@Component</p>
<ol>
<li>指定类</li>
<li>指定beanName</li>
<li>指定scope</li>
<li>指定工厂方法</li>
<li>指定工厂bean</li>
<li>指定init method</li>
<li>指定 destory method</li>
</ol>
<p>@Autowired @Qualifier</p>
<ol>
<li>指定构造参数依赖</li>
</ol>
<p>@Value</p>
<ol>
<li>指定属性依赖</li>
</ol>
<h2 id="如何指定配置？"><a href="#如何指定配置？" class="headerlink" title="如何指定配置？"></a>如何指定配置？</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210810222619.png"></p>
<p>需要为用户提供一种方式？</p>
<h2 id="Bean配置解析应当在哪里完成？"><a href="#Bean配置解析应当在哪里完成？" class="headerlink" title="Bean配置解析应当在哪里完成？"></a>Bean配置解析应当在哪里完成？</h2><p><strong>该放在BeanFactory中吗？</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210810223055.png"></p>
<p>方框中所做的事情是解析bean配置，向beanFactory注册bean定义。它不是beanFactory的事情。</p>
<p>应单独定义接口、类来完成这件事</p>
<h2 id="ApplicationContext接口设计"><a href="#ApplicationContext接口设计" class="headerlink" title="ApplicationContext接口设计"></a>ApplicationContext接口设计</h2><p><strong>ApplicationContext用来完成Bean配置解析</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814192652.png"></p>
<p><strong>Xml配置方式的实现</strong></p>
<p>Xml源可能是多个</p>
<p>完成的工作：加载、解析、创建、注册</p>
<p><strong>注解配置方式的实现</strong></p>
<p>扫描的包多个：list</p>
<p>完成工作：扫描、获取、创建、注册</p>
<p><strong>它们都将要使用BeanFactory&#x2F;BeanDefinitionRegistry，将BeanFactory抽出来放到父类中</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814192937.png"></p>
<p><strong>用户要使用我们的框架需要知道哪些接口、类？</strong></p>
<ol>
<li>指定配置相关，xml、annotation</li>
<li>获取bean相关，BeanFactory</li>
</ol>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814193341.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814193458.png"></p>
<p>外观模式应用：让用户只需要知道ApplicationContext及其子类是否对用户更简单？如何完成？</p>
<p><strong>提供一个新的外观（外观模式应用）</strong></p>
<p>ApplicationContext继承自BeanFactory，两个接口合并到一起</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814193747.png"></p>
<h1 id="实现配置过程"><a href="#实现配置过程" class="headerlink" title="实现配置过程"></a>实现配置过程</h1><h2 id="配置怎么加载及扫描？"><a href="#配置怎么加载及扫描？" class="headerlink" title="配置怎么加载及扫描？"></a>配置怎么加载及扫描？</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814194039.png"></p>
<h2 id="XML文件来源处理"><a href="#XML文件来源处理" class="headerlink" title="XML文件来源处理"></a>XML文件来源处理</h2><p><strong>Xml配置文件来源会有多种吗？</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814194401.png"></p>
<p><strong>它们的加载方式一样吗？</strong></p>
<p>不一样</p>
<p><strong>对于XML解析来说，从加载过程它希望获得的是什么？</strong></p>
<p>InputStream</p>
<p>我们希望能加载不同来源的xml,向解析提供一致的使用接口。如何做？如何设计接口、类？</p>
<p><strong>Xml配置文件接口类的设计</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814194704.png"></p>
<p>问题：这里我们定义不同的Resource类对应不同来源的xml资源，谁去负责分辨创建它们的对象？</p>
<p>因为用户给定时是一个个的字符串（这对他们是最简单的方式）。</p>
<h2 id="XML资源加载器"><a href="#XML资源加载器" class="headerlink" title="XML资源加载器"></a>XML资源加载器</h2><p><strong>用户使用字符串定义资源，需要一个资源加载器分辨不同的资源</strong></p>
<p>分辨字符串，创建对应的Resource对象的工作就是加载，由ApplicationContext来做。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814195818.png"></p>
<p>如何区分不同的字符串代表不同的资源？</p>
<p>定义字符创规则</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814200049.png"></p>
<p>这里有需要应用工厂模式的味道：根据不同的字符串前缀创建不同的资源对象</p>
<h2 id="注解如何扫描？"><a href="#注解如何扫描？" class="headerlink" title="注解如何扫描？"></a>注解如何扫描？</h2><p><strong>到指定的包目录下找出所有的类文件（包含子孙包下的）</strong></p>
<p>![image-20210814201431315](C:\Users\chen cheng\AppData\Roaming\Typora\typora-user-images\image-20210814201431315.png)</p>
<p>思考：如果要扫描的是com.study下所有service包下的类，这个逻辑满足吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ant path</span><br><span class="line">com/study/**/service/*</span><br></pre></td></tr></table></figure>

<p>该怎么办？</p>
<p>定义一个资源路径匹配行为</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814201603.png"></p>
<h2 id="扫描的最终结果"><a href="#扫描的最终结果" class="headerlink" title="扫描的最终结果"></a>扫描的最终结果</h2><p>扫到了指定包下的所有class文件，我们最终需要的是什么？</p>
<p><strong>我们需要的是类名</strong></p>
<p>这里我们需要定义什么样的接口、类？</p>
<p>最终扫描到的是class文件，File即可</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814201832.png"></p>
<h2 id="Annotation扫描工作"><a href="#Annotation扫描工作" class="headerlink" title="Annotation扫描工作"></a>Annotation扫描工作</h2><p>扫描的事情是由AnnotationApplicationContext来做还是外包给其他类来做？</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814202225.png"></p>
<p>在哪里启动扫描？</p>
<p>AnnotationApplicationContext 构造方法中</p>
<h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814202505.png"></p>
<p>加载和扫描的输出是什么？</p>
<p>Resource</p>
<h1 id="配置的最终结果"><a href="#配置的最终结果" class="headerlink" title="配置的最终结果"></a>配置的最终结果</h1><h2 id="扫描结果与BeanDefinition"><a href="#扫描结果与BeanDefinition" class="headerlink" title="扫描结果与BeanDefinition"></a>扫描结果与BeanDefinition</h2><p>XML和注解最终的输出都是Resource，这个Resource如何解析成BeanDefinition？怎么设计？</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814202936.png"></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814203158.png"></p>
<h2 id="最终完整类图"><a href="#最终完整类图" class="headerlink" title="最终完整类图"></a>最终完整类图</h2><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210814203645.png"></p>
<h1 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h1><p><a target="_blank" rel="noopener" href="https://github.com/chengchen901/spring-custom-study.git">https://github.com/chengchen901/spring-custom-study.git</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/02-Spring/04-%E6%89%8B%E5%86%99Spring%E9%85%8D%E7%BD%AE/" data-id="clmcxecsi006su8wa9nffd9tq" data-title="手写Spring配置" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-02-Spring/05-Spring源码-IOC容器初始化过程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/02-Spring/05-Spring%E6%BA%90%E7%A0%81-IOC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/02-Spring/05-Spring%E6%BA%90%E7%A0%81-IOC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/">Spring源码-IOC容器初始化过程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="探索框架源码学习"><a href="#探索框架源码学习" class="headerlink" title="探索框架源码学习"></a>探索框架源码学习</h1><h2 id="为什么要学习源码？"><a href="#为什么要学习源码？" class="headerlink" title="为什么要学习源码？"></a>为什么要学习源码？</h2><p>为扩展、调优：掌握框架的工作流程、原理。</p>
<p>为提升自己的编程技能：学习他人的设计思想、编程技巧、涨薪升职。</p>
<h2 id="学习源码技巧"><a href="#学习源码技巧" class="headerlink" title="学习源码技巧"></a>学习源码技巧</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><ol>
<li>掌握问题域理论和核心概念：搞明白做什么，如何做。</li>
<li>从整体到部分</li>
<li>找到入口，先理清主干流程，再细节</li>
<li>多折腾、勤折腾</li>
</ol>
<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><ol>
<li>掌握问题域理论和核心概念：搞明白做什么，如何做。</li>
<li>动手自己尝试实现。</li>
<li>对比看源码的实现思路，总结优劣，学习他人之长。</li>
</ol>
<h3 id="方法技巧"><a href="#方法技巧" class="headerlink" title="方法技巧"></a>方法技巧</h3><ol>
<li><p>建立干净的项目环境</p>
</li>
<li><p>会使用基本的用例</p>
</li>
<li><p>猜测了解整个流程</p>
</li>
<li><p>抓住整个流程关键点</p>
</li>
<li><p>设置断点，分析断点调用栈</p>
<ol>
<li><p>分析类名、包名、方法名、输入输出</p>
</li>
<li><p>拆分出实现的关键块</p>
</li>
<li><p>拆分出实现的关键方法</p>
</li>
<li><p>进入该方法</p>
</li>
<li><p>逐步调试动态分析，F7、F8、F9 快捷键的使用</p>
</li>
<li><p>对于陌生类，养成查看官方注释的习惯</p>
</li>
<li><p>巧用IDE进行静态分析<br>快捷键以IDEA为IDE</p>
<ol>
<li>断点的使用技巧<br>找到关键方法点设置断点条件断点，同一个断点被多次调用，但只关心某个值的情况下进行拦截</li>
<li>定位搜索相关类<br>Ctrl+N 匹配类名<br>Ctrl+F12或Alt+7 类中查找方法</li>
<li>查看方法调用关系链<br>Ctrl+Alt+H打开方法调用链层级Open Call Hierarchy 被地方调用的调用层级，调用其他方法的层</li>
<li>查找被使用的地方<br>Ctrl+B或Ctrl+Alt+B 查看被其他方法调用的地方</li>
<li>利用生成UML类图分析复杂关系</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="IOC容器源码解读"><a href="#IOC容器源码解读" class="headerlink" title="IOC容器源码解读"></a>IOC容器源码解读</h1><h2 id="IOC容器初始化过程"><a href="#IOC容器初始化过程" class="headerlink" title="IOC容器初始化过程"></a>IOC容器初始化过程</h2><h3 id="ApplicationContext用法及工作流程"><a href="#ApplicationContext用法及工作流程" class="headerlink" title="ApplicationContext用法及工作流程"></a>ApplicationContext用法及工作流程</h3><ul>
<li><p>回顾IOC容器<br>IOC容器，为用户提供创建、管理、获取它们的类实例的容器。让用户在需要类对象时，只需向IOC容器要，进而达到与具体类解耦。为其他的高级功能提供基础。<br>IOC需要完成下列工作，才能被使用：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210818145336.png"></p>
</li>
<li><p>Spring的用法</p>
<p>源码项目准备</p>
<p>新建一个普通的java maven 工程，引入spring ioc 的jar，排除其他依赖，只需要一个干净纯粹的环境</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用spring的三种方式：xml配置、注解、bean配置。</p>
<ul>
<li><p>XML</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;chinaUser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.ChinaUser&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;garfieldCat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;garfieldCat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.spring.bean.GarfieldCat&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;罐头&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;chinaUser&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;hash&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChinaUser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;hash&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChinaUser</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML方式指定扫描包范围</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study.spring&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注解方式指定扫描的基础包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.study.spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中通过API直接指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.study.spring.bean&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;hash&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">context.scan(<span class="string">&quot;com.study.spring.bean&quot;</span>);</span><br><span class="line">context.refresh();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(User.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java Bean配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    context.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">    context.register(AdditionalConfig.class);</span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的使用示例，很清楚地看到，我们使用Spring ，只需要使用spring提供的ApplicationContext这个API。ApplicationContext 就是IOC容器。源码的学习就从它开始！</p>
</li>
</ul>
</li>
</ul>
<h3 id="ApplicationContext继承体系"><a href="#ApplicationContext继承体系" class="headerlink" title="ApplicationContext继承体系"></a>ApplicationContext继承体系</h3><h4 id="带着问题学习ApplicationContext"><a href="#带着问题学习ApplicationContext" class="headerlink" title="带着问题学习ApplicationContext"></a>带着问题学习ApplicationContext</h4><ol>
<li><p>它是什么？它有什么？</p>
</li>
<li><p>怎么使用它？它都有什么实现类？区别是什么？</p>
</li>
<li><p>它是的初始化过程是怎样的？</p>
</li>
<li><p>如何加载解析bean定义的？</p>
<ol>
<li>xml的解析过程是怎样的？</li>
<li>注解的扫描过程是怎样的？</li>
</ol>
</li>
<li><p>还想了解什么？</p>
</li>
</ol>
<h4 id="ApplicationContext是什么？"><a href="#ApplicationContext是什么？" class="headerlink" title="ApplicationContext是什么？"></a>ApplicationContext是什么？</h4><p>IOC容器，提供IOC容器应用配置的普通接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory,</span><br><span class="line">		MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ApplicationContext的继承体系"><a href="#ApplicationContext的继承体系" class="headerlink" title="ApplicationContext的继承体系"></a>ApplicationContext的继承体系</h4><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210818161541.png"></p>
<table>
<thead>
<tr>
<th><strong>父接口</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>EnvironmentCapable</td>
<td>具有取环境相关参数的功能，propertiess文件</td>
</tr>
<tr>
<td>ListableBeanFactory</td>
<td>提供Bean迭代功能的BeanFactory</td>
</tr>
<tr>
<td>HierarchicalBeanFactory</td>
<td>提供父容器的访问功能的BeanFactory</td>
</tr>
<tr>
<td>MessageSource</td>
<td>对国际化文件支持的基础接口</td>
</tr>
<tr>
<td>ApplicationEventPublisher</td>
<td>应用事件发布接口</td>
</tr>
<tr>
<td>ResourcePatternResolver</td>
<td>资源解析加载接口</td>
</tr>
</tbody></table>
<p>每个角色的职责和方法都有哪些？</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210818163208.png"></p>
<ul>
<li><p>Environment接口</p>
<p>用来表示整个应用运行时的环境，为了更形象地理解Environment，你可以把Spring应用的运行时简单地想象成两个部分：一个是Spring应用本身，一个是Spring应用所处的环境。除了外部的各种各方面配置文件，还有一个profile配置，定义bean逻辑组。</p>
</li>
<li><p>HierarchicalBeanFactory接口</p>
<p>工厂分层接口，getParentBeanFactory获得父工厂，只能子读父工厂。containsLocalBean本工厂是否包含某个bean。</p>
</li>
<li><p>ApplicationContext提供的方法</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210818163929.png"></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getId</td>
<td>IOC容器的唯一id名</td>
</tr>
<tr>
<td>getApplicationName</td>
<td>返回应用名</td>
</tr>
<tr>
<td>getDisplayName</td>
<td>易于理解的说明用的，展示名</td>
</tr>
<tr>
<td>getStartupDate</td>
<td>容器启动时间</td>
</tr>
<tr>
<td>getParent</td>
<td>获得父容器，类似父子工厂</td>
</tr>
<tr>
<td>getAutowireCapableBeanFactory</td>
<td>获得自动装配的Bean工厂</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="ApplicationContext的实现体系"><a href="#ApplicationContext的实现体系" class="headerlink" title="ApplicationContext的实现体系"></a>ApplicationContext的实现体系</h4><ul>
<li><p>体系图</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210818164301.png"></p>
<p>从AbstarctApplicationContext之后分为两类：xml配置方式的实现和通用实现。</p>
<p><strong>Xml这条线往，了解具体实现的构造方法、构造方法的源码是怎样的？</strong></p>
<p>可以打开每个子类去了解它们分别加入了什么、分别提供了哪些基本实现。</p>
</li>
<li><p>ConfigurableApplicationContext子接口</p>
<p>可配置的ApplicationContext接口，提供了父容器、环境、BeanFactory后置处理器、监听器等配置方法。</p>
<p>提供可获得ConfigurableListableBeanFactory接口的方法</p>
<p>实现了Lifecycle、Closeable接口，意味着能够进行生命周期的控制和关闭操作。</p>
</li>
<li><p>AbstractApplicationContext抽象实现类</p>
<p>进行了大量通用的接口方法实现，包括ApplicationContext、ConfigurableApplicationContext、BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、MessageSource、ResourcePatternResolver、Lifecycle 8个父接口的方法实现。为子类的实现进行了大量减负，遗留refreshBeanFactory、closeBeanFactory、getBeanFactory方法给子类实现。</p>
<p>最重要的方法：refresh，ApplicationContext初始化加载过程的呈现</p>
<p><strong>AbstractRefreshableApplicationContext、GenericApplicationContext子类实现是两个重要的分支。</strong></p>
</li>
<li><p>AbstractRefreshableApplicationContext</p>
<ul>
<li>自1.1.3版本提供的抽象实现，提供bean工厂刷新方法的实现，可以配置是否允许重写bean定义以及循环依赖。AbstractRefreshableConfigApplicationContext子类则增加了资源配置入口，通过Environment解析出配置的真实资源路径字符串。</li>
<li>它的子类实现是指定了资源的加载方式，比如XML资源方式的子类实现：ClassPathXmlApplicationContext、FileSystemXmlApplicationContext。</li>
</ul>
</li>
<li><p>GenericApplicationContext</p>
<ul>
<li>它实现了BeanDefinitionRegistry接口，该接口定义了bean定义信息的注册行为。即我们可以直接往GenericApplicationContext中注册bean定义。</li>
<li>GenericApplicationContext 中是不是持有DefaultListableBeanFactory?是的<br>GenericApplicationContext的bean定义注册是不是委托给了持有的DefaultListableBeanFactory？是的</li>
<li>相关实现有：AnnotationConfigApplicationContext 注解配置、GenericGroovyApplicationContext groovy方式配置、GenericXmlApplicationContext 通用的xml配置、StaticApplicationContext 静态资源配置方式。</li>
<li>AnnotationConfigApplicationContex 了解它的构造方法、register方法。看它的源码。</li>
<li>GenericXmlApplicationContext 了解它的构造方法、load方法，看源码</li>
<li>它的子类是通用的资源加载方式，通过资源的reader接口和bean资源扫描接口，外包任务，来实现统一通用的方式。</li>
</ul>
</li>
</ul>
<p>可以看出AbstractRefreshableApplicationContext是继承式逐步扩展，</p>
<p>GenericApplicationContext则是组合式扩展。</p>
<ul>
<li><p>实现类有什么区别？如何使用？</p>
<p>ApplicationContext接口一共有6个实现类</p>
<ul>
<li>两种XML指定加载方式实现：<ul>
<li>ClassPathXmlApplicationContext 项目下配置文件</li>
<li>FileSystemXmlApplicationContext 文件系统配置文件</li>
</ul>
</li>
<li>四种通用加载方式实现：<ul>
<li>AnnotationConfigApplicationContext 注解配置</li>
<li>GenericGroovyApplicationContext groovy方式配置</li>
<li>GenericXmlApplicationContext 通用的xml配置</li>
<li>StaticApplicationContext 编程方式进行方式配置资源，常用于配置场景</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ApplicationContext实现类的基本使用方式见示例，示例可以看出他们的之间的区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) context.getBean(<span class="string">&quot;garfieldCat&quot;</span>);</span><br><span class="line">    System.out.println(cat.getName());</span><br><span class="line"></span><br><span class="line">    context = <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\\CodingStudy\\spring-source-code\\src\\main\\resources\\application.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;chinaUser&quot;</span>);</span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line"></span><br><span class="line">    context = <span class="keyword">new</span> <span class="title class_">GenericXmlApplicationContext</span>(<span class="string">&quot;file:D:\\CodingStudy\\spring-source-code\\src\\main\\resources\\application.xml&quot;</span>);</span><br><span class="line">    cat = (Cat) context.getBean(<span class="string">&quot;garfieldCat&quot;</span>);</span><br><span class="line">    System.out.println(cat.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    context = <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Application.class);</span><br><span class="line">    user = (User) context.getBean(<span class="string">&quot;hash&quot;</span>);</span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">cac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(cac).loadBeanDefinitions(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(cac).scan(<span class="string">&quot;com.study.spring&quot;</span>);</span><br><span class="line">    <span class="comment">// 一定要刷新</span></span><br><span class="line">    cac.refresh();</span><br><span class="line"></span><br><span class="line">    user = cac.getBean(<span class="string">&quot;hash&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line"></span><br><span class="line">    cat = cac.getBean(Cat.class);</span><br><span class="line">    System.out.println(cat.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用法跟GenericApplicationContext一样</span></span><br><span class="line">    <span class="type">StaticApplicationContext</span> <span class="variable">sac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticApplicationContext</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(sac).loadBeanDefinitions(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(sac).scan(<span class="string">&quot;com.study.spring&quot;</span>);</span><br><span class="line">    <span class="comment">// 一定要刷新</span></span><br><span class="line">    sac.refresh();</span><br><span class="line"></span><br><span class="line">    user = sac.getBean(<span class="string">&quot;hash&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanFactory继承体系"><a href="#BeanFactory继承体系" class="headerlink" title="BeanFactory继承体系"></a>BeanFactory继承体系</h3><ul>
<li><p>BeanFacotry和ApplicationContext的关系</p>
<p>从前面的源码中分析中得到BeanFactory接口在ApplicationContext容器中继承体系中，在实现体系中的AbstractRefreshableConfigApplicationContext、GenericApplicationContext 实现类则持有BeanFactory接口的DefaultListableBeanFactory实例。<br>关系如图：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210818174709.png"></p>
<p>ApplicationContext与BeanFactory的关系非常简单，持有组合关系，但是BeanFactory与DefaultListableBeanFactory的关系就错综复杂了，这里有三条路径从DefaultListableBeanFactory到BeanFactory。</p>
</li>
<li><p>BeanFactory的继承体系是怎么样的？</p>
<p>将类图简化</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210818175259.png"></p>
</li>
<li><p>有哪些实现类？</p>
<p>BeanFactory实现体系图</p>
<p>![image-20210818212520867](C:\Users\chen cheng\AppData\Roaming\Typora\typora-user-images\image-20210818212520867.png)</p>
<ul>
<li><p>关键实现类：DefaultListableBeanFactory</p>
<p>整个BeanFactory接口实现体系验证了软件界《三国演义》，开篇结尾的话：“天下大势合久必分，分久必合”。</p>
<p>直接的子接口下分了三条路，呈现出三国鼎立之势，各有各的特点：ListableBeanFactory可迭代、AutowireCapableBeanFactory可自动注入、HierarchicalBeanFactory具有父子关系。</p>
<p>经过一列演变，最终归而为一，ConfigurableListableBeanFactory接口继承了三个接口特点，自成一体。</p>
<p>DefaultListableBeanFactory类就是ConfigurableListableBeanFactory接口最终的实现，XmlBeanFactory则在Spring 3.1中废除。</p>
</li>
<li><p>其他的实现类<br>StaticListableBeanFactory 用于编程遍历的实现<br>SimpleJndiBeanFactory 用于JNDI，简单的实现自BeanFactory接口</p>
</li>
</ul>
</li>
</ul>
<h3 id="ApplicationContext的初始化过程"><a href="#ApplicationContext的初始化过程" class="headerlink" title="ApplicationContext的初始化过程"></a>ApplicationContext的初始化过程</h3><p>学习完IOC容器的基本结构，我们再来分析分析IOC容器的初始化过程。</p>
<ul>
<li><p>如何分析？<br>断点，跟代码，同时画调用图。<br>我们在示例代码中设置断点，一步一步调试进去，看看整个过程是怎么样的。</p>
</li>
<li><p>ClassPathXmlApplicationContext为例跟踪初始化过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.study.Application#main org.springframework.context.support.ClassPathXmlApplicationContext#ClassPath <span class="title function_">XmlApplicationContext</span><span class="params">(java.lang.String)</span> org.springframework.context.support.ClassPathXmlApplicationContext#ClassPath <span class="title function_">XmlApplicationContext</span><span class="params">(java.lang.String[], <span class="type">boolean</span>, org.springframework.context.ApplicationContext)</span> org.springframework.context.support.AbstractApplicationContext#refresh</span><br></pre></td></tr></table></figure>

<p>将目光往回调到AbstractApplicationContext.refresh方法，设置断点，运行示例代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    <span class="comment">// 为刷新做准备，初始化各种状态，启动时间、关闭激活状态、配置文件信息等</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="comment">// 通知子类刷新内部BeanFactory，并返回刷新后的BeanFactory</span></span><br><span class="line">    <span class="comment">// 关注方法中的refreshBeanFactory方法，两个子类对它重写的差异</span></span><br><span class="line">    <span class="comment">//  AbstractRefreshableApplicationContext#refreshBeanFactory中重新构建，完成BeanDefinition的解析构建</span></span><br><span class="line">    <span class="comment">// GenericApplicationContext#refreshBeanFactory则是设置ID，并且只能刷新一次</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    <span class="comment">// 给容器准备BeanFactory，配置相关的属性</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">        <span class="comment">// 允许子类处理后置beanFactory</span></span><br><span class="line">        postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">        <span class="comment">//  调用注册了beanFactory后置处理器接口实例bean对应的方法</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">        <span class="comment">// 注册bean后置处理器接口的实例bean</span></span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">        <span class="comment">// 初始化国际化资源</span></span><br><span class="line">        initMessageSource();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">        <span class="comment">// 初始化事件传播者</span></span><br><span class="line">        initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">        <span class="comment">// refresh事件，初始化一些指定的bean</span></span><br><span class="line">        onRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">        <span class="comment">// 注册监听器bean</span></span><br><span class="line">        registerListeners();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">        <span class="comment">// 完成bean工厂的初始化，初始化所有非懒加载的单例bean</span></span><br><span class="line">        finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">        <span class="comment">// 最后，发布finishRefresh事件</span></span><br><span class="line">        finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">        <span class="comment">// 销毁了所有已经创建了的单例bean</span></span><br><span class="line">        destroyBeans();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">        <span class="comment">// 重置active标记</span></span><br><span class="line">        cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">        <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">        resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refresh方法，里面的每一个方法都是一个重要的步骤，里面的每个步骤，我们目前还不进行深入分析，等后面会有专门的内容来深入。</p>
</li>
<li><p>GenericXmlApplicationContext类</p>
<p>发现最终都会到org.springframework.context.support.AbstractApplicationContext#refresh方法上整个容器的初始化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.study.Application#main org.springframework.context.support.GenericXmlApplicationContext#GenericXmlA <span class="title function_">pplicationContext</span><span class="params">(java.lang.String...)</span> org.springframework.context.support.GenericXmlApplicationContext#load(java.l ang.String...) org.springframework.beans.factory.support.AbstractBeanDefinitionReader#loadB <span class="title function_">eanDefinitions</span><span class="params">(java.lang.String...)</span> org.springframework.context.support.AbstractApplicationContext#refresh</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/02-Spring/05-Spring%E6%BA%90%E7%A0%81-IOC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/" data-id="clmcxecsw006vu8wa2rxo52pd" data-title="Spring源码-IOC容器初始化过程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-02-Spring/06-Spring源码-Bean定义加载过程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/02-Spring/06-Spring%E6%BA%90%E7%A0%81-Bean%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/02-Spring/06-Spring%E6%BA%90%E7%A0%81-Bean%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">Spring源码-Bean定义加载过程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Bean定义加载过程解读"><a href="#Bean定义加载过程解读" class="headerlink" title="Bean定义加载过程解读"></a>Bean定义加载过程解读</h1><ul>
<li>介绍BeanDefinition接口定义</li>
<li>介绍BeanDefinition的继承体系</li>
<li>XML方式Bean定义加载过程</li>
<li>注解方式Bean定义扫描过程</li>
</ul>
<h2 id="Bean定义详解"><a href="#Bean定义详解" class="headerlink" title="Bean定义详解"></a>Bean定义详解</h2><p>BeanDefinition，bean定义的接口行为描述。</p>
<p>BeanDefinition接口中定义了Bean定义的相关行为，我们从中可看到很多熟悉的项。如对里面的信息项不熟，请查看代码的注释。同时请对比看xml配置的dtd或xsd，在beans.jar中org.springframework.beans.factory.xml 包下：spring-beans.dtd 或 spring-beans.xsd。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A BeanDefinition describes a bean instance, which has property values, constructor argument values, and further information</span></span><br><span class="line"><span class="comment"> * supplied by concrete implementations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">AttributeAccessor</span>, BeanMetadataElement &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean定义接口的常用方法如下：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820100249.png"></p>
<h2 id="BeanDefinition继承体系"><a href="#BeanDefinition继承体系" class="headerlink" title="BeanDefinition继承体系"></a>BeanDefinition继承体系</h2><p>了解一下BeanDefinition的继承体系，看看它的实现类</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820101354.png"></p>
<p>在2.5前用RootBeanDefinition、ChildBeanDefinition。在2.5版本后新增了四个接口类，推荐使用，GenericBeanDefinition、AnnotatedGenericBeanDefinition两个类都是2.5版本后引入的类、接口。</p>
<table>
<thead>
<tr>
<th>父接口</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>AttributeAccessor</td>
<td>接口定义了用于向任意对象附加和访问元数据的通用契约。</td>
</tr>
<tr>
<td>BeanMetadataElement</td>
<td>接口由携带配置源对象的bean元数据元素实现。</td>
</tr>
</tbody></table>
<h2 id="BeanDefinitionRegistry-Bean定义注册"><a href="#BeanDefinitionRegistry-Bean定义注册" class="headerlink" title="BeanDefinitionRegistry Bean定义注册"></a>BeanDefinitionRegistry Bean定义注册</h2><p>Bean定义的信息最终注册到哪里去了呢？查看BeanDefinitionRegistry接口信息。</p>
<p>BeanDefinitionRegistry接口定义了bean定义信息的注册行为。BeanDefinitionRegistry中定义的行为：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820103448.png"></p>
<p><strong>BeanDefinitionRegistry继承体系</strong></p>
<p>通过BeanDefinitionRegistry的继承体系可以发现，SimpleBeanDefinitionRegistry、DefaultLlistableBeanFactory和GenericApplicationContext中实现了接口的方法，我们可以通过他们进行注册bean定义。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820104125.png"></p>
<p>查看GenericApplicationContext源码，它本质上是通过DefaultLlistableBeanFactory实例来完成Bean定义注册的。正在原生实现BeanDefinitionRegistry接口的只有两个类：SimpleBeanDefinitionRegistry、DefaultLlistableBeanFactory。在目前的环境中SimpleBeanDefinitionRegistry没有被使用到</p>
<h2 id="XML加载与解析"><a href="#XML加载与解析" class="headerlink" title="XML加载与解析"></a>XML加载与解析</h2><p>回顾前面的内容，XML资源加载流程如下</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820105252.png"></p>
<h3 id="调试分析XML加载方式"><a href="#调试分析XML加载方式" class="headerlink" title="调试分析XML加载方式"></a>调试分析XML加载方式</h3><ul>
<li><p>怎么动态调试分析？<br>找到关键点，Bean定义实现类GenericBeanDefinition#setBeanClassName，设置断点，并且设置条件。<br>“com.study.spring.bean.GarfieldCat”.equals(beanClassName)</p>
</li>
<li><p>如何进行分析？<br>保留调用栈，查看包、类、方法、输入输出的变化</p>
</li>
</ul>
<p>ClassPathXmlApplicationContext方式，参考示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 断点位置</span></span><br><span class="line">setBeanClassName:<span class="number">386</span>, AbstractBeanDefinition (org.springframework.beans.factory.support)</span><br><span class="line"><span class="comment">// 最终在BeanDefinitionReaderUtils中构建GenericBeanDefinition对象</span></span><br><span class="line">createBeanDefinition(String, String, ClassLoader):<span class="number">67</span>, BeanDefinitionReaderUtils (org.springframework.beans.factory.support) <span class="comment">/*BeanDefinition解析器*/</span></span><br><span class="line"><span class="comment">// 创建BeanDefinition对象</span></span><br><span class="line">createBeanDefinition(String, String):<span class="number">642</span>, BeanDefinitionParserDelegate (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 解析单个 &lt;bean/&gt; 节点，将相关属性装入BeanDefinition对象中</span></span><br><span class="line">parseBeanDefinitionElement(Element, String, BeanDefinition):<span class="number">515</span>, BeanDefinitionParserDelegate (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 构建BeanDefinitionHolder，能够处理别名情况</span></span><br><span class="line">parseBeanDefinitionElement(Element, BeanDefinition):<span class="number">437</span>, BeanDefinitionParserDelegate (org.springframework.beans.factory.xml) parseBeanDefinitionElement(Element):<span class="number">405</span>, BeanDefinitionParserDelegate (org.springframework.beans.factory.xml)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** BeanDefinitionReder-XmlBeanDefinitionReader 处理堆栈信息*/</span></span><br><span class="line"><span class="comment">// 获得BeanDefinitionHolder对象，并注入BeanFactory中</span></span><br><span class="line"><span class="comment">// 解析BeanDefinition中的参数属性值：BeanComponentDefinition</span></span><br><span class="line"><span class="comment">// 激活Reader中的组件注册事件</span></span><br><span class="line">processBeanDefinition(Element, BeanDefinitionParserDelegate):<span class="number">306</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 拆解xml中的默认各个元素节点：beans、bean、import、alias</span></span><br><span class="line">parseDefaultElement(Element, BeanDefinitionParserDelegate):<span class="number">197</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 从xml文件的根节点开始解析内容</span></span><br><span class="line"><span class="comment">// 拆解其他扩展元素 &lt;aop/&gt; &lt;config/&gt;由 parseCustomElement方法通过命名空间来完成</span></span><br><span class="line">parseBeanDefinitions(Element, BeanDefinitionParserDelegate):<span class="number">176</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册BeanDefinition过程：DefaultBeanDefinitionDocumentReader*/</span></span><br><span class="line"><span class="comment">// 正在开始进行xml 父节点拆解的方法</span></span><br><span class="line">doRegisterBeanDefinitions(Element):<span class="number">149</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// documentReader XML文档解读类进行解析xml文件</span></span><br><span class="line">registerBeanDefinitions(Document, XmlReaderContext):<span class="number">96</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 通过DefaultBeanDefinitionDocumentReader对象解读xml，并计算解析到的bean定义个数</span></span><br><span class="line">registerBeanDefinitions(Document, Resource):<span class="number">511</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// BeanDefinition资源加载过程：Resource解读为Document，解析Document</span></span><br><span class="line">doLoadBeanDefinitions(InputSource, Resource):<span class="number">391</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) loadBeanDefinitions(EncodedResource):<span class="number">338</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) loadBeanDefinitions(Resource):<span class="number">310</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 将多个资源进行循环解析加载</span></span><br><span class="line">loadBeanDefinitions(Resource[]):<span class="number">188</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String, Set):<span class="number">224</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String):<span class="number">195</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String[]):<span class="number">257</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IOC 容器加载堆栈 */</span></span><br><span class="line"><span class="comment">// 解读xml配置的关键转折点</span></span><br><span class="line">loadBeanDefinitions(XmlBeanDefinitionReader):<span class="number">128</span>, AbstractXmlApplicationContext (org.springframework.context.support)</span><br><span class="line"><span class="comment">// new XmlBeanDefinitionReader解读器对象，开始进入解读状态</span></span><br><span class="line">loadBeanDefinitions(DefaultListableBeanFactory):<span class="number">94</span>, AbstractXmlApplicationContext (org.springframework.context.support) refreshBeanFactory():<span class="number">130</span>, AbstractRefreshableApplicationContext (org.springframework.context.support)</span><br><span class="line">obtainFreshBeanFactory():<span class="number">638</span>, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh():<span class="number">523</span>, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;(String[], <span class="type">boolean</span>, ApplicationContext):<span class="number">144</span>,ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;(String):<span class="number">85</span>, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line"><span class="comment">// 启动类</span></span><br><span class="line">main(String[]):<span class="number">20</span>, Application (com.study)</span><br></pre></td></tr></table></figure>

<p>关键节点：</p>
<p><strong>ClassPathXmlApplicationContext</strong>.<init></p>
<p><strong>AbstractApplicationContext.refresh</strong> -&gt; obtainFreshBeanFactory -&gt; refreshBeanFactory</p>
<p><strong>AbstractXmlApplicationContext.loadBeanDefinitions</strong></p>
<p><strong>AbstractBeanDefinitionReader.loadBeanDefinitions</strong></p>
<p><strong>XmlBeanDefinitionReader.loadBeanDefinitions</strong> -&gt; doLoadBeanDefinitions -&gt; registerBeanDefinitions</p>
<p>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions -&gt; doRegisterBeanDefinitions -&gt; processBeanDefinition</p>
<p>BeanDefinitionParserDelegate.parseBeanDefinitionElement -&gt; createBeanDefinition</p>
<p>BeanDefinitionReaderUtils.createBeanDefinition</p>
<p>AbstractBeanDefinition.setBeanClassName</p>
<h3 id="XML的解析"><a href="#XML的解析" class="headerlink" title="XML的解析"></a>XML的解析</h3><p>关键流程在于Resource转Document转Element转成Bean定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** BeanDefinitionReder-XmlBeanDefinitionReader 处理堆栈信息*/</span></span><br><span class="line"><span class="comment">// 获得BeanDefinitionHolder对象，并注入BeanFactory中</span></span><br><span class="line"><span class="comment">// 解析BeanDefinition中的参数属性值：BeanComponentDefinition</span></span><br><span class="line"><span class="comment">// 激活Reader中的组件注册事件</span></span><br><span class="line">processBeanDefinition(Element, BeanDefinitionParserDelegate):<span class="number">306</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 拆解xml中的默认各个元素节点：beans、bean、import、alias</span></span><br><span class="line">parseDefaultElement(Element, BeanDefinitionParserDelegate):<span class="number">197</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 从xml文件的根节点开始解析内容</span></span><br><span class="line"><span class="comment">// 拆解其他扩展元素 &lt;aop/&gt; &lt;config/&gt;由 parseCustomElement方法通过命名空间来完成</span></span><br><span class="line">parseBeanDefinitions(Element, BeanDefinitionParserDelegate):<span class="number">176</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册BeanDefinition过程：DefaultBeanDefinitionDocumentReader*/</span></span><br><span class="line"><span class="comment">// 正在开始进行xml 父节点拆解的方法</span></span><br><span class="line">doRegisterBeanDefinitions(Element):<span class="number">149</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// documentReader XML文档解读类进行解析xml文件</span></span><br><span class="line">registerBeanDefinitions(Document, XmlReaderContext):<span class="number">96</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 通过DefaultBeanDefinitionDocumentReader对象解读xml，并计算解析到的bean定义个数</span></span><br><span class="line">registerBeanDefinitions(Document, Resource):<span class="number">511</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// BeanDefinition资源加载过程：Resource解读为Document，解析Document</span></span><br><span class="line">doLoadBeanDefinitions(InputSource, Resource):<span class="number">391</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)</span><br></pre></td></tr></table></figure>

<h3 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h3><p>经过前面的分析，所有的Bean定义注册都将在DefaultListableBeanFactory.registerBeanDefinition方法执行，我们在这个地方打断点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必定经过的地方，进行埋伏，可以得到整个调用链 </span></span><br><span class="line">registerBeanDefinition(String, BeanDefinition):<span class="number">929</span>, DefaultListableBeanFactory (org.springframework.beans.factory.support) registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry):<span class="number">164</span>, BeanDefinitionReaderUtils (org.springframework.beans.factory.support) </span><br><span class="line">processBeanDefinition(Element, BeanDefinitionParserDelegate):<span class="number">311</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml) </span><br><span class="line"><span class="comment">// 后面都是加载解读XML的过程了，前面已经分析过了 </span></span><br><span class="line">parseDefaultElement(Element, BeanDefinitionParserDelegate):<span class="number">197</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml) </span><br><span class="line">parseBeanDefinitions(Element, BeanDefinitionParserDelegate):<span class="number">176</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml) </span><br><span class="line">doRegisterBeanDefinitions(Element):<span class="number">149</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml) registerBeanDefinitions(Document, XmlReaderContext):<span class="number">96</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml) </span><br><span class="line">registerBeanDefinitions(Document, Resource):<span class="number">511</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) doLoadBeanDefinitions(InputSource, Resource):<span class="number">391</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) loadBeanDefinitions(EncodedResource):<span class="number">338</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) loadBeanDefinitions(Resource):<span class="number">310</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) loadBeanDefinitions(Resource[]):<span class="number">188</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String, Set):<span class="number">224</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String):<span class="number">195</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String[]):<span class="number">257</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(XmlBeanDefinitionReader):<span class="number">128</span>, AbstractXmlApplicationContext (org.springframework.context.support) loadBeanDefinitions(DefaultListableBeanFactory):<span class="number">94</span>, AbstractXmlApplicationContext (org.springframework.context.support) refreshBeanFactory():<span class="number">130</span>, AbstractRefreshableApplicationContext (org.springframework.context.support) obtainFreshBeanFactory():<span class="number">638</span>, AbstractApplicationContext (org.springframework.context.support) </span><br><span class="line">refresh():<span class="number">523</span>, AbstractApplicationContext (org.springframework.context.support) </span><br><span class="line">&lt;init&gt;(String[], <span class="type">boolean</span>, ApplicationContext):<span class="number">144</span>, ClassPathXmlApplicationContext (org.springframework.context.support) </span><br><span class="line">&lt;init&gt;(String):<span class="number">85</span>, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">main(String[]):<span class="number">20</span>, Application (com.study)</span><br></pre></td></tr></table></figure>

<h3 id="Spring中扩展XML标签"><a href="#Spring中扩展XML标签" class="headerlink" title="Spring中扩展XML标签"></a>Spring中扩展XML标签</h3><p>在DefaultBeanDefinitionDocumentReader#parseBeanDefinitions(Element, BeanDefinitionParserDelegate)方法中的自定义标签解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不是默认的命名空间，扩展的标签交给代理进行处理</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinitionParserDelegate#parseCustomElement(Element, BeanDefinition) 方法内部实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得命名空间 URI</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceUri</span> <span class="operator">=</span> getNamespaceURI(ele);</span><br><span class="line">    <span class="keyword">if</span> (namespaceUri == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造命名空间处理器</span></span><br><span class="line">    <span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交给处理器解析</span></span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> <span class="title class_">ParserContext</span>(<span class="built_in">this</span>.readerContext, <span class="built_in">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820160144.png"></p>
<p>看看beans、context、aop jar包下的META-INF&#x2F;spring.handlers文件</p>
<p>xml中以后扩展标签，只需要添加配置、扩展实现类。实现功能即插即用，灵活扩展。</p>
<p><strong>请思考</strong>： </p>
<p>1、如果你需要加一个自己开发的模块（含自定义的bean定义标签）到spring中，你是否可以做到了。</p>
<p> 2、spring标签处理这里的设计：模块之间可以灵活组合，配置在各自的模块中，即插即用。</p>
<p>请大家自己定义一个模块，定义自定义配置标签，实现自己的NamespaceHandler，打包集成到spring中。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>XML方式最终是通过GenericBeanDefinition类进行Bean定义的装载</p>
<p>XML加载流程</p>
<p>ClassPathXmlApplicationContext.<init></p>
<p>AbstractApplicationContext.refresh -&gt; obtainFreshBeanFactory -&gt; refreshBeanFactory</p>
<p>AbstractXmlApplicationContext.loadBeanDefinitions</p>
<p>XML配置可以进行方便的扩展，类似Dubbo集成到Spring中那样</p>
<p>最终所有的Bean定义都是通过DefaultListableBeanFactory注册到Bean工厂</p>
<h2 id="注解扫描过程解读"><a href="#注解扫描过程解读" class="headerlink" title="注解扫描过程解读"></a>注解扫描过程解读</h2><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><p>经过前面的学习，知道入口为AnnotationConfigApplicationContext类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.study.spring.bean&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;hash&quot;</span>);</span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们该在哪里拦截分析？DefaultListableBeanFactory.registerBeanDefinition方法</p>
<h3 id="注解的加载处理"><a href="#注解的加载处理" class="headerlink" title="注解的加载处理"></a>注解的加载处理</h3><p>AnnotationConfigApplicationContext，在构造函数中构建了AnnotatedBeanDefinitionReader、ClassPathBeanDefinitionScanner对象。</p>
<p>注解准备工作，初始化注解处理组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 往bean工厂中注册【注解处理器】的bean定义</span></span><br><span class="line">registerBeanDefinition(String, BeanDefinition):<span class="number">929</span>, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">registerBeanDefinition(String, BeanDefinition):<span class="number">323</span>, GenericApplicationContext (org.springframework.context.support)</span><br><span class="line"><span class="comment">//  3. 通过方法名，注册注解配置的Processor，注册到内部BeanFactory中。是什么Processor呢？</span></span><br><span class="line">registerPostProcessor(BeanDefinitionRegistry, RootBeanDefinition, String):<span class="number">216</span>, AnnotationConfigUtils (org.springframework.context.annotation)</span><br><span class="line">registerAnnotationConfigProcessors(BeanDefinitionRegistry, Object):<span class="number">166</span>, AnnotationConfigUtils (org.springframework.context.annotation)</span><br><span class="line">registerAnnotationConfigProcessors(BeanDefinitionRegistry):<span class="number">137</span>, AnnotationConfigUtils (org.springframework.context.annotation)</span><br><span class="line"><span class="comment">// 2. 初始化 AnnotatedBeanDefinitionReader 对象</span></span><br><span class="line">&lt;init&gt;(BeanDefinitionRegistry, Environment):<span class="number">88</span>, AnnotatedBeanDefinitionReader (org.springframework.context.annotation)</span><br><span class="line">&lt;init&gt;(BeanDefinitionRegistry):<span class="number">71</span>, AnnotatedBeanDefinitionReader (org.springframework.context.annotation)</span><br><span class="line"><span class="comment">// 1. 执行AnnotationConfigApplicationContext的构造函数</span></span><br><span class="line">&lt;init&gt;():<span class="number">66</span>, AnnotationConfigApplicationContext (org.springframework.context.annotation)</span><br><span class="line">&lt;init&gt;(String[]):<span class="number">99</span>, AnnotationConfigApplicationContext (org.springframework.context.annotation)</span><br><span class="line"><span class="comment">// 0. 启动类</span></span><br><span class="line">main(String[]):<span class="number">9</span>, AnnotationConfig (com.study.spring.runner)</span><br></pre></td></tr></table></figure>

<p>注册的怎么不是我们的Bean定义而是Processor呢？</p>
<p>在这个调用栈中，我们并发没有看到它做包扫描的相关工作。从下往上看这个执行栈，点第2个，我们来</p>
<p>看看代码：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210822173738.png"></p>
<p>通过前面的学习，这里还没有扫描我们指定的包 basePackages，还只是ApplicationContext的初始化函数中。扫描在第二步 scan方法中，第三步才会refresh。也就是跟xml有点不一样，在构造函数中就开始了各种初始化准备。</p>
<p>它现在是在做一些初始化的准备处理，从这里我们获知，它做了registerAnnotationConfigProcessors。从名字上理解就是注册了一些注解配置的处理器。到底是一些什么processors，点方法进去看看：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210822173903.png"></p>
<p>注册所有相关的注解 post processor给registry，进入方法查看相关代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 上面的一段我们可以不用了解，跟我们的目标不符合</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将需要用到的各种处理器编制成Bean定义，好注入到工厂中，作为bean使用。</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">	<span class="comment">// 重点看下面的注册相关的代码</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// ConfigurationClassPostProcessor.class，@Configuration注解类后置处理器</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// AutowiredAnnotationBeanPostProcessor.class</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// CommonAnnotationBeanPostProcessor.class 通用注解后置处理器</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// 如果有JPA的支持，则加入相关的注解处理器</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                                                AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;Cannot load optional framework class: &quot;</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 最终返回各种处理器的bean定义列表</span></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来除了我们自己的应用bean，Spring自己内部也有各种bean注入到工厂，用来处理各种逻辑，比如这里的注解Bean定义的相关处理对象，都是通过Bean定义注入Bean工厂的。</p>
<p>这么多的processor，都是些什么Processor？点第一个的类名ConfigurationClassPostProcessor进去看看。</p>
<h4 id="BeanFactoryPostProcessor作用"><a href="#BeanFactoryPostProcessor作用" class="headerlink" title="BeanFactoryPostProcessor作用"></a>BeanFactoryPostProcessor作用</h4><ul>
<li><p>ConfigurationClassPostProcessor接口</p>
<p>看注释，启动阶段用来处理@Configuration注解的BeanFactoryPostProcessor，但是没有看到BeanFactoryPostProcessor接口的继承，但是有一个BeanDefinitionRegistryPostProcessor。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823092347.png"></p>
</li>
<li><p>ConfigurationClassPostProcessor的继承结构</p>
<p>通过IDE查看继承体系结构，果不然，它的爷爷就是BeanFactoryPostProcessor。 </p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823092647.png"></p>
<p>BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，增加了BeanDefinitionRegistry位置的处理，即它可以提前对注册好的BeanDefinitionRegistry进行前置处理。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823093216.png"></p>
<p>BeanFactoryPostProcessor到底用来做什么的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory hook that allows for custom modification of an application context&#x27;s</span></span><br><span class="line"><span class="comment"> * bean definitions, adapting the bean property values of the context&#x27;s underlying</span></span><br><span class="line"><span class="comment"> * bean factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Useful for custom config files targeted at system administrators that</span></span><br><span class="line"><span class="comment"> * override bean properties configured in the application context. See</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> PropertyResourceConfigurer&#125; and its concrete implementations for</span></span><br><span class="line"><span class="comment"> * out-of-the-box solutions that address such configuration needs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125; may interact with and modify bean</span></span><br><span class="line"><span class="comment"> * definitions, but never bean instances. Doing so may cause premature bean</span></span><br><span class="line"><span class="comment"> * instantiation, violating the container and causing unintended side-effects.</span></span><br><span class="line"><span class="comment"> * If bean instance interaction is required, consider implementing</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BeanPostProcessor&#125; instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Registration&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An &#123;<span class="doctag">@code</span> ApplicationContext&#125; auto-detects &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * beans in its bean definitions and applies them before any other beans get created.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125; may also be registered programmatically</span></span><br><span class="line"><span class="comment"> * with a &#123;<span class="doctag">@code</span> ConfigurableApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Ordering&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125; beans that are autodetected in an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ApplicationContext&#125; will be ordered according to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.PriorityOrdered&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.Ordered&#125; semantics. In contrast,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125; beans that are registered programmatically</span></span><br><span class="line"><span class="comment"> * with a &#123;<span class="doctag">@code</span> ConfigurableApplicationContext&#125; will be applied in the order of</span></span><br><span class="line"><span class="comment"> * registration; any ordering semantics expressed through implementing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> PriorityOrdered&#125; or &#123;<span class="doctag">@code</span> Ordered&#125; interface will be ignored for</span></span><br><span class="line"><span class="comment"> * programmatically registered post-processors. Furthermore, the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.annotation.Order <span class="doctag">@Order</span>&#125; annotation is not</span></span><br><span class="line"><span class="comment"> * taken into account for &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125; beans.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam Brannen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 06.07.2003</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> PropertyResourceConfigurer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 所有的Bean定义加载完成，还未进行实例化前，对BeanFactory中的bean定义可进行想要做的处理。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment">	 * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment">	 * will have been instantiated yet. This allows for overriding or adding</span></span><br><span class="line"><span class="comment">	 * properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它对应的实现有PropertyResourceConfigurer、EventListenerMethodProcessor等，见图。<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823094149.png"></p>
<p>那么此时我们明白了这些Processor的作用，这样用Spring注解配置的类，都能通过这些ProcessorBean对象来进行处理相关的逻辑了。</p>
<p>这是springIOC中给我们提供的又一个【扩展点】，让我们可以在beanFactory开始创建Bean实例前对beanFactory进行一些处理。我们可以来试试：</p>
<p>自己实现一个BeanFactoryPostProcessor： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span> + <span class="string">&quot; 工作了..................................&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.study.spring.bean&quot;</span>, <span class="string">&quot;com.study.spring.ext&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;hash&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在哪里创建并执行的这个MyBeanFactoryPostProcessor？</p>
<p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823100239.png"></p>
<p>如果想了解其他的BeanFactoryPostProcessor都干了些什么，在它的实现方法里面打上断点进行调试。</p>
<p><strong>IOC容器与BeanFactoryPostProcessor的关系</strong><br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823100858.png"></p>
</li>
</ul>
<h3 id="注解的扫描"><a href="#注解的扫描" class="headerlink" title="注解的扫描"></a>注解的扫描</h3><p>接下来，我们看看注解的扫描过程，添加断点<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823101307.png"></p>
<p>到此处然后释放拦截，到DefaultListableBeanFactory.registerBeanDefinition断点得到调用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成bean定义到bean工厂的注册</span></span><br><span class="line">registerBeanDefinition(String, BeanDefinition):<span class="number">929</span>, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">registerBeanDefinition(String, BeanDefinition):<span class="number">323</span>, GenericApplicationContext (org.springframework.context.support)</span><br><span class="line">registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry):<span class="number">164</span>, BeanDefinitionReaderUtils (org.springframework.beans.factory.support)</span><br><span class="line">registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry):<span class="number">320</span>, ClassPathBeanDefinitionScanner (org.springframework.context.annotation)</span><br><span class="line"><span class="comment">// 完成包名下的Bean定义扫描</span></span><br><span class="line">doScan(String[]):<span class="number">292</span>, ClassPathBeanDefinitionScanner (org.springframework.context.annotation)</span><br><span class="line"><span class="comment">// 构建并初始化ClassPathBeanDefinitionScanner扫描器对象，开始进行扫描</span></span><br><span class="line">scan(String[]):<span class="number">254</span>, ClassPathBeanDefinitionScanner (org.springframework.context.annotation)</span><br><span class="line">scan(String[]):<span class="number">176</span>, AnnotationConfigApplicationContext (org.springframework.context.annotation)</span><br><span class="line">&lt;init&gt;(String[]):<span class="number">100</span>, AnnotationConfigApplicationContext (org.springframework.context.annotation)</span><br><span class="line">main(String[]):<span class="number">9</span>, AnnotationConfig (com.study.spring.runner)</span><br></pre></td></tr></table></figure>

<p>从调用栈上我们可看到有哪些类参与进来，在哪里发生的什么。</p>
<p>找到ClassPathBeanDefinitionScanner#doScan方法，设置断点进行分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Perform a scan within the specified base packages,</span></span><br><span class="line"><span class="comment"> * returning the registered bean definitions.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor</span></span><br><span class="line"><span class="comment"> * but rather leaves this up to the caller.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> set of beans registered if any for tooling registration purposes (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">	Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 1 遍历要扫描的包</span></span><br><span class="line">	<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">// 2 找到指定包下所有候选组件（配置的bean）</span></span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">		<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">			<span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">			candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">			<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">				postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">				AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">				<span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">				definitionHolder =</span><br><span class="line">						AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">				beanDefinitions.add(definitionHolder);</span><br><span class="line">                <span class="comment">// 3 注册bean定义到BeanFactory中</span></span><br><span class="line">				registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，真正完成的Bean定义的扫描工作，进入findCandidateComponents方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan the class path for candidate components.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePackage the package to check for annotated classes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a corresponding Set of autodetected bean definitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title function_">findCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">	<span class="comment">// 这段代码的逻辑：如果有组件索引并且索引支持包含的filters，就从组件索引中获取获选组件</span></span><br><span class="line">    <span class="comment">// 组件索引是什么？</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.componentsIndex != <span class="literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">		<span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="built_in">this</span>.componentsIndex, basePackage);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，进行类目录下指定包的扫描</span></span><br><span class="line">		<span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件索引请阅读：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/core.html#beans-scanning-index">https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/core.html#beans-scanning-index</a></p>
<h4 id="扫描执行"><a href="#扫描执行" class="headerlink" title="扫描执行"></a>扫描执行</h4><p>接下来查看，包下类执行扫描的方法：</p>
<p>ClassPathScanningCandidateComponentProvider#scanCandidateComponents，重点代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建扫描包的路径表达式，类似切点表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">            resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">        <span class="comment">// ResourcePatternResolver扫描包获取到.class文件</span></span><br><span class="line">        <span class="comment">// 扫描的逻辑：在包下找.class文件，这里要求能够灵活指定包，就需要用到模式匹配</span></span><br><span class="line">        <span class="comment">// 默认用到的Ant Path模式匹配，如指定的包 com.study.**.service</span></span><br><span class="line">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">	<span class="comment">// ...... 省略一堆代码</span></span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入getResourcePatternResolver方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ResourcePatternResolver <span class="title function_">getResourcePatternResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.resourcePatternResolver == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourcePatternResolver = <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.resourcePatternResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  能将指定的资源位置路径解析为一个或多个匹配的资源。可以是一对一的资源指定，也可以是一对多的匹配模式，通过ant path格式、classpath*:前缀。</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> ResourcePatternResolver&#125; implementation that is able to resolve a</span></span><br><span class="line"><span class="comment"> * specified resource location path into one or more matching Resources.</span></span><br><span class="line"><span class="comment"> * The source path may be a simple path which has a one-to-one mapping to a</span></span><br><span class="line"><span class="comment"> * target &#123;<span class="doctag">@link</span> org.springframework.core.io.Resource&#125;, or alternatively</span></span><br><span class="line"><span class="comment"> * may contain the special &quot;&#123;<span class="doctag">@code</span> classpath*:&#125;&quot; prefix and/or</span></span><br><span class="line"><span class="comment"> * internal Ant-style regular expressions (matched using Spring&#x27;s</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.util.AntPathMatcher&#125; utility).</span></span><br><span class="line"><span class="comment"> * Both of the latter are effectively wildcards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;No Wildcards:&lt;/b&gt; 无通配符模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In the simple case, if the specified location path does not start with the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> &quot;classpath*:&#125;&quot; prefix, and does not contain a PathMatcher pattern,</span></span><br><span class="line"><span class="comment"> * this resolver will simply return a single resource via a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> getResource()&#125; call on the underlying &#123;<span class="doctag">@code</span> ResourceLoader&#125;.</span></span><br><span class="line"><span class="comment"> * Examples are real URLs such as &quot;&#123;<span class="doctag">@code</span> file:C:/context.xml&#125;&quot;, pseudo-URLs</span></span><br><span class="line"><span class="comment"> * such as &quot;&#123;<span class="doctag">@code</span> classpath:/context.xml&#125;&quot;, and simple unprefixed paths</span></span><br><span class="line"><span class="comment"> * such as &quot;&#123;<span class="doctag">@code</span> /WEB-INF/context.xml&#125;&quot;. The latter will resolve in a</span></span><br><span class="line"><span class="comment"> * fashion specific to the underlying &#123;<span class="doctag">@code</span> ResourceLoader&#125; (e.g.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ServletContextResource&#125; for a &#123;<span class="doctag">@code</span> WebApplicationContext&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Ant-style Patterns:&lt;/b&gt;  ant风格模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;When the path location contains an Ant-style pattern, e.g.:</span></span><br><span class="line"><span class="comment"> * &lt;pre class=&quot;code&quot;&gt;</span></span><br><span class="line"><span class="comment"> * /WEB-INF/*-context.xml</span></span><br><span class="line"><span class="comment"> * com/mycompany/**&amp;#47;applicationContext.xml</span></span><br><span class="line"><span class="comment"> * file:C:/some/path/*-context.xml</span></span><br><span class="line"><span class="comment"> * classpath:com/mycompany/**&amp;#47;applicationContext.xml&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * the resolver follows a more complex but defined procedure to try to resolve</span></span><br><span class="line"><span class="comment"> * the wildcard. It produces a &#123;<span class="doctag">@code</span> Resource&#125; for the path up to the last</span></span><br><span class="line"><span class="comment"> * non-wildcard segment and obtains a &#123;<span class="doctag">@code</span> URL&#125; from it. If this URL is</span></span><br><span class="line"><span class="comment"> * not a &quot;&#123;<span class="doctag">@code</span> jar:&#125;&quot; URL or container-specific variant (e.g.</span></span><br><span class="line"><span class="comment"> * &quot;&#123;<span class="doctag">@code</span> zip:&#125;&quot; in WebLogic, &quot;&#123;<span class="doctag">@code</span> wsjar&#125;&quot; in WebSphere&quot;, etc.),</span></span><br><span class="line"><span class="comment"> * then a &#123;<span class="doctag">@code</span> java.io.File&#125; is obtained from it, and used to resolve the</span></span><br><span class="line"><span class="comment"> * wildcard by walking the filesystem. In the case of a jar URL, the resolver</span></span><br><span class="line"><span class="comment"> * either gets a &#123;<span class="doctag">@code</span> java.net.JarURLConnection&#125; from it, or manually parses</span></span><br><span class="line"><span class="comment"> * the jar URL, and then traverses the contents of the jar file, to resolve the</span></span><br><span class="line"><span class="comment"> * wildcards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Implications on portability:&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the specified path is already a file URL (either explicitly, or</span></span><br><span class="line"><span class="comment"> * implicitly because the base &#123;<span class="doctag">@code</span> ResourceLoader&#125; is a filesystem one,</span></span><br><span class="line"><span class="comment"> * then wildcarding is guaranteed to work in a completely portable fashion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the specified path is a classpath location, then the resolver must</span></span><br><span class="line"><span class="comment"> * obtain the last non-wildcard path segment URL via a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Classloader.getResource()&#125; call. Since this is just a</span></span><br><span class="line"><span class="comment"> * node of the path (not the file at the end) it is actually undefined</span></span><br><span class="line"><span class="comment"> * (in the ClassLoader Javadocs) exactly what sort of a URL is returned in</span></span><br><span class="line"><span class="comment"> * this case. In practice, it is usually a &#123;<span class="doctag">@code</span> java.io.File&#125; representing</span></span><br><span class="line"><span class="comment"> * the directory, where the classpath resource resolves to a filesystem</span></span><br><span class="line"><span class="comment"> * location, or a jar URL of some sort, where the classpath resource resolves</span></span><br><span class="line"><span class="comment"> * to a jar location. Still, there is a portability concern on this operation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a jar URL is obtained for the last non-wildcard segment, the resolver</span></span><br><span class="line"><span class="comment"> * must be able to get a &#123;<span class="doctag">@code</span> java.net.JarURLConnection&#125; from it, or</span></span><br><span class="line"><span class="comment"> * manually parse the jar URL, to be able to walk the contents of the jar,</span></span><br><span class="line"><span class="comment"> * and resolve the wildcard. This will work in most environments, but will</span></span><br><span class="line"><span class="comment"> * fail in others, and it is strongly recommended that the wildcard</span></span><br><span class="line"><span class="comment"> * resolution of resources coming from jars be thoroughly tested in your</span></span><br><span class="line"><span class="comment"> * specific environment before you rely on it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;&#123;<span class="doctag">@code</span> classpath*:&#125; Prefix:&lt;/b&gt; classpath*:前缀的模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There is special support for retrieving multiple class path resources with</span></span><br><span class="line"><span class="comment"> * the same name, via the &quot;&#123;<span class="doctag">@code</span> classpath*:&#125;&quot; prefix. For example,</span></span><br><span class="line"><span class="comment"> * &quot;&#123;<span class="doctag">@code</span> classpath*:META-INF/beans.xml&#125;&quot; will find all &quot;beans.xml&quot;</span></span><br><span class="line"><span class="comment"> * files in the class path, be it in &quot;classes&quot; directories or in JAR files.</span></span><br><span class="line"><span class="comment"> * This is particularly useful for autodetecting config files of the same name</span></span><br><span class="line"><span class="comment"> * at the same location within each jar file. Internally, this happens via a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassLoader.getResources()&#125; call, and is completely portable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &quot;classpath*:&quot; prefix can also be combined with a PathMatcher pattern in</span></span><br><span class="line"><span class="comment"> * the rest of the location path, for example &quot;classpath*:META-INF/*-beans.xml&quot;.</span></span><br><span class="line"><span class="comment"> * In this case, the resolution strategy is fairly simple: a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassLoader.getResources()&#125; call is used on the last non-wildcard</span></span><br><span class="line"><span class="comment"> * path segment to get all the matching resources in the class loader hierarchy,</span></span><br><span class="line"><span class="comment"> * and then off each resource the same PathMatcher resolution strategy described</span></span><br><span class="line"><span class="comment"> * above is used for the wildcard subpath.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Other notes:&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;WARNING:&lt;/b&gt; Note that &quot;&#123;<span class="doctag">@code</span> classpath*:&#125;&quot; when combined with</span></span><br><span class="line"><span class="comment"> * Ant-style patterns will only work reliably with at least one root directory</span></span><br><span class="line"><span class="comment"> * before the pattern starts, unless the actual target files reside in the file</span></span><br><span class="line"><span class="comment"> * system. This means that a pattern like &quot;&#123;<span class="doctag">@code</span> classpath*:*.xml&#125;&quot; will</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;not&lt;/i&gt; retrieve files from the root of jar files but rather only from the</span></span><br><span class="line"><span class="comment"> * root of expanded directories. This originates from a limitation in the JDK&#x27;s</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassLoader.getResources()&#125; method which only returns file system</span></span><br><span class="line"><span class="comment"> * locations for a passed-in empty String (indicating potential roots to search).</span></span><br><span class="line"><span class="comment"> * This &#123;<span class="doctag">@code</span> ResourcePatternResolver&#125; implementation is trying to mitigate the</span></span><br><span class="line"><span class="comment"> * jar root lookup limitation through &#123;<span class="doctag">@link</span> URLClassLoader&#125; introspection and</span></span><br><span class="line"><span class="comment"> * &quot;java.class.path&quot; manifest evaluation; however, without portability guarantees.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;WARNING:&lt;/b&gt; Ant-style patterns with &quot;classpath:&quot; resources are not</span></span><br><span class="line"><span class="comment"> * guaranteed to find matching resources if the root package to search is available</span></span><br><span class="line"><span class="comment"> * in multiple class path locations. This is because a resource such as</span></span><br><span class="line"><span class="comment"> * &lt;pre class=&quot;code&quot;&gt;</span></span><br><span class="line"><span class="comment"> *     com/mycompany/package1/service-context.xml</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * may be in only one location, but when a path such as</span></span><br><span class="line"><span class="comment"> * &lt;pre class=&quot;code&quot;&gt;</span></span><br><span class="line"><span class="comment"> *     classpath:com/mycompany/**&amp;#47;service-context.xml</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * is used to try to resolve it, the resolver will work off the (first) URL</span></span><br><span class="line"><span class="comment"> * returned by &#123;<span class="doctag">@code</span> getResource(&quot;com/mycompany&quot;);&#125;. If this base package node</span></span><br><span class="line"><span class="comment"> * exists in multiple classloader locations, the actual end resource may not be</span></span><br><span class="line"><span class="comment"> * underneath. Therefore, preferably, use &quot;&#123;<span class="doctag">@code</span> classpath*:&#125;&quot; with the same</span></span><br><span class="line"><span class="comment"> * Ant-style pattern in such a case, which will search &lt;i&gt;all&lt;/i&gt; class path</span></span><br><span class="line"><span class="comment"> * locations that contain the root package.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Colin Sampaleanu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Marius Bogoevici</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Costin Leau</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CLASSPATH_ALL_URL_PREFIX</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.util.AntPathMatcher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.io.ResourceLoader#getResource(String)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ClassLoader#getResources(String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathMatchingResourcePatternResolver</span> <span class="keyword">implements</span> <span class="title class_">ResourcePatternResolver</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 默认采用AntPathMatcher</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">PathMatcher</span> <span class="variable">pathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式匹配，关系图</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823110241.png"></p>
<h3 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h3><h4 id="带着问题"><a href="#带着问题" class="headerlink" title="带着问题"></a>带着问题</h4><p>如何从.class文件中获得注解信息呢？</p>
<p>思考：我们自己实现时是如何获取并解析的？</p>
<ol>
<li>Class.forname(“className”)加载类获得Class对象</li>
<li>反射获取注解？</li>
<li>判断是否存在组件注解，存在为其创建BeanDefinition</li>
<li>看指定了名字没，如没，根据名字生成策略生成一个名字</li>
<li>注册BeanDefinition</li>
</ol>
<h4 id="Spring中的解析过程"><a href="#Spring中的解析过程" class="headerlink" title="Spring中的解析过程"></a>Spring中的解析过程</h4><ol>
<li><p>找源码中读取注解的地方<br>ClassPathScanningCandidateComponentProvider#scanCandidateComponents，重点代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建扫描包的路径表达式，类似切点表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">            resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">        <span class="comment">// ResourcePatternResolver扫描包获取到.class文件</span></span><br><span class="line">        <span class="comment">// 扫描的逻辑：在包下找.class文件，这里要求能够灵活指定包，就需要用到模式匹配</span></span><br><span class="line">        <span class="comment">// 默认用到的Ant Path模式匹配，如指定的包 com.study.**.service</span></span><br><span class="line">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">traceEnabled</span> <span class="operator">=</span> logger.isTraceEnabled();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Scanning &quot;</span> + resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// MetadataReader，元数据读取器，类似xml读取器？</span></span><br><span class="line">                    <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">                    <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                        <span class="comment">// 最终通过MetadataReader用ScannedGenericBeanDefinition装载了注解bean定义</span></span><br><span class="line">                        <span class="type">ScannedGenericBeanDefinition</span> <span class="variable">sbd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">                        sbd.setSource(resource);</span><br><span class="line">                        <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Identified candidate component class: &quot;</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                            candidates.add(sbd);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                            logger.trace(<span class="string">&quot;Ignored because not matching any filter: &quot;</span> + resource);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                        <span class="string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                    logger.trace(<span class="string">&quot;Ignored because not readable: &quot;</span> + resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="ScannedGenericBeanDefinition"><a href="#ScannedGenericBeanDefinition" class="headerlink" title="ScannedGenericBeanDefinition"></a>ScannedGenericBeanDefinition</h4><p>ScannedGenericBeanDefinition类的内部实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extension of the &#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.GenericBeanDefinition&#125;</span></span><br><span class="line"><span class="comment"> * class, based on an ASM ClassReader, with support for annotation metadata exposed</span></span><br><span class="line"><span class="comment"> * through the &#123;<span class="doctag">@link</span> AnnotatedBeanDefinition&#125; interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 继承自GenericBeanDefinition类，基于ASM ClassReader的AnnotatedBeanDefinition实现，支持注解元数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class does &lt;i&gt;not&lt;/i&gt; load the bean &#123;<span class="doctag">@code</span> Class&#125; early.</span></span><br><span class="line"><span class="comment"> * It rather retrieves all relevant metadata from the &quot;.class&quot; file itself,</span></span><br><span class="line"><span class="comment"> * parsed with the ASM ClassReader. It is functionally equivalent to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AnnotatedGenericBeanDefinition#AnnotatedGenericBeanDefinition(AnnotationMetadata)&#125;</span></span><br><span class="line"><span class="comment"> * but distinguishes by type beans that have been &lt;em&gt;scanned&lt;/em&gt; vs those that have</span></span><br><span class="line"><span class="comment"> * been otherwise registered or detected by other means.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getMetadata()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanClassName()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.type.classreading.MetadataReaderFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotatedGenericBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannedGenericBeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">GenericBeanDefinition</span> <span class="keyword">implements</span> <span class="title class_">AnnotatedBeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata metadata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new ScannedGenericBeanDefinition for the class that the</span></span><br><span class="line"><span class="comment">	 * given MetadataReader describes.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> metadataReader the MetadataReader for the scanned target class</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ScannedGenericBeanDefinition</span><span class="params">(MetadataReader metadataReader)</span> &#123;</span><br><span class="line">		Assert.notNull(metadataReader, <span class="string">&quot;MetadataReader must not be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">		setBeanClassName(<span class="built_in">this</span>.metadata.getClassName());</span><br><span class="line">		setResource(metadataReader.getResource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> AnnotationMetadata <span class="title function_">getMetadata</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.metadata;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> MethodMetadata <span class="title function_">getFactoryMethodMetadata</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回看BeanDefinition的继承体系结构</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820101354.png"></p>
<p>ScannedGenericBeanDefinition是AnnotatedBeanDefinition接口的实现类</p>
<p><strong>注解Bean定义的疑问</strong></p>
<ol>
<li>为什么2.5要增加AnnotatedBeanDefinition？用GenericBeanDefinition不可以吗？</li>
<li>是不是注解方式的Bean定义信息的存放及使用方式与通用Bean定义方式不一样了？</li>
</ol>
<p>上面问题的答案我们只能从创建bean定义和实例化bean时的源码中找答案了。</p>
<ul>
<li><p>首先来搞清楚AnnotatedBeanDefinition接口中增加的两个get。</p>
<ul>
<li><p>这两个get获取的是谁上的信息？</p>
<p>被注解的类上的。</p>
</li>
<li><p>那就搞的清楚两个get返回的是什么了：</p>
<ul>
<li>AnnotationMetadata : 类上的注解的元信息</li>
<li>getFactoryMethodMetadata(): MethodMetadata : 如果是工厂方法方式，获取工厂方法元信息。这个方法是4.1.1才开始有的。在context.jar的范围未看到有使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以看出来AnnotatedBeanDefinition是在Spring2.5才加入的，getFactoryMethodMetadata方法是4.1.1才加入的。这些都是后期新增特性才提供的。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823130243.png"></p>
<p><strong>元数据信息</strong></p>
<ul>
<li><p>疑问：AnnotationMetadata、MethodMetaData、ClassMetadata所谓的元信息是什么？</p>
<p>Spring中定义的一套方案来描述一个类、一个类上的注解、一个方法等的描述接口，里面定义一些相关的操作。</p>
<p>比如：</p>
<ul>
<li>类：类的名称是什么，它有什么修饰符等</li>
<li>注解：类上的注解的名字，注解的元注解信息有什么、注解的注释信息是什么，注解里面有哪些属性等。</li>
</ul>
<p>在org.springframework.core.type包下定义了相关的接口，可以进行了解</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823130954.png"></p>
</li>
</ul>
<h4 id="MetadataReader"><a href="#MetadataReader" class="headerlink" title="MetadataReader"></a>MetadataReader</h4><p>MetadataReader接口定义如下，通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple facade for accessing class metadata,</span></span><br><span class="line"><span class="comment"> * as read by an ASM &#123;<span class="doctag">@link</span> org.springframework.asm.ClassReader&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过ASM的ClassReader读取类的元信息，提供一个简单的外观模式。</span></span><br><span class="line"><span class="comment"> * 1. 用ASM来实现这个功能；2. 这是一个简单的外观模式实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MetadataReader</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the resource reference for the class file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Resource <span class="title function_">getResource</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Read basic class metadata for the underlying class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ClassMetadata <span class="title function_">getClassMetadata</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Read full annotation metadata for the underlying class,</span></span><br><span class="line"><span class="comment">	 * including metadata for annotated methods.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	AnnotationMetadata <span class="title function_">getAnnotationMetadata</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> MetadataReader&#125; implementation based on an ASM</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.asm.ClassReader&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Costin Leau</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SimpleMetadataReader</span> <span class="keyword">implements</span> <span class="title class_">MetadataReader</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PARSING_OPTIONS</span> <span class="operator">=</span> ClassReader.SKIP_DEBUG</span><br><span class="line">			| ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Resource resource;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata annotationMetadata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	SimpleMetadataReader(Resource resource, <span class="meta">@Nullable</span> ClassLoader classLoader) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 构建注解元数据读取访问者</span></span><br><span class="line">		<span class="type">SimpleAnnotationMetadataReadingVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAnnotationMetadataReadingVisitor</span>(classLoader);</span><br><span class="line">        <span class="comment">// 创建资源对应的ASM ClassReader对象，并且对用visitor对ClassReader对象进行访问解读</span></span><br><span class="line">		getClassReader(resource).accept(visitor, PARSING_OPTIONS);</span><br><span class="line">        <span class="comment">// 扫描到的带有注解的类</span></span><br><span class="line">		<span class="built_in">this</span>.resource = resource;</span><br><span class="line">        <span class="comment">// 获得注解元数据信息</span></span><br><span class="line">		<span class="built_in">this</span>.annotationMetadata = visitor.getMetadata();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ClassReader <span class="title function_">getClassReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> resource.getInputStream()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(is);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;ASM ClassReader failed to parse class file - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;probably due to a new Java class file version that isn&#x27;t supported yet: &quot;</span> + resource, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Resource <span class="title function_">getResource</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.resource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ClassMetadata <span class="title function_">getClassMetadata</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.annotationMetadata;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> AnnotationMetadata <span class="title function_">getAnnotationMetadata</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.annotationMetadata;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ASM是什么？</strong></p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://asm.ow2.io/">https://asm.ow2.io/</a></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823131653.png"></p>
<p>总结：Spring中通过ASM字节码操作库来读取的类信息、注解信息，又学到了一种方式来获取类中的信息，它们的类关系图如下。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823131838.png"></p>
<p>提问：spring中通过ASM字节码操作库来读取的类信息、注解信息。它没有加载类，为什么不用加载类的方式？</p>
<ol>
<li>反射是读取持久堆上存储的类信息。而 ASM 是直接处理 .class 字节码。性能比反射快。</li>
<li>反射读取类信息时需要进行类加载处理，而 ASM 则不需要将类加载到内存中。内存占用比反射低。</li>
<li>反射只能读取类信息，而 ASM 除了读还能写。</li>
</ol>
<p>反射相对于 ASM 来说使用方便，想直接操纵 ASM 的话需要有 JVM 指令基础。</p>
<h4 id="MetadataReader与ScannedGenericBeanDefinition"><a href="#MetadataReader与ScannedGenericBeanDefinition" class="headerlink" title="MetadataReader与ScannedGenericBeanDefinition"></a>MetadataReader与ScannedGenericBeanDefinition</h4><p>MetadataReader读取到类信息、注解信息后，如何进行判断及创建BeanDefinition的，往BeanDefintion中给入了哪些信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">            resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">traceEnabled</span> <span class="operator">=</span> logger.isTraceEnabled();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Scanning &quot;</span> + resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// MetadataReader，元数据读取器，类似xml读取器？</span></span><br><span class="line">                    <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">                    <span class="comment">// 1. 判断是否是候选组件？进入方法看看</span></span><br><span class="line">                    <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                        <span class="comment">// 2. MetadataReader给ScannedGenericBeanDefinition装载什么信息？</span></span><br><span class="line">                        <span class="type">ScannedGenericBeanDefinition</span> <span class="variable">sbd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">                        sbd.setSource(resource);</span><br><span class="line">                        <span class="comment">// 3. 必须是一个可以继承的类，不能是接口和封闭类，抽象类必须有Lookup注解</span></span><br><span class="line">                        <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Identified candidate component class: &quot;</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                            candidates.add(sbd);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123; <span class="comment">// 忽略，不是一个顶层的具体类</span></span><br><span class="line">                            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// 忽略，不能匹配到过滤器</span></span><br><span class="line">                        <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                            logger.trace(<span class="string">&quot;Ignored because not matching any filter: &quot;</span> + resource);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                        <span class="string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                    logger.trace(<span class="string">&quot;Ignored because not readable: &quot;</span> + resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扫描过滤器</strong></p>
<ol>
<li>过滤匹配处要搞清楚的内容：<ol>
<li>Filter从何而来，默认情况下有什么filter？</li>
<li>匹配的过程是怎样的？</li>
<li>@service @controller等是怎么匹配到的？</li>
</ol>
</li>
</ol>
<p>ClassPathScanningCandidateComponentProvider#isCandidateComponent(MetadataReader) 488</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeFilter tf : <span class="built_in">this</span>.excludeFilters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (TypeFilter tf : <span class="built_in">this</span>.includeFilters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">            <span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Filter从何而来，默认情况下有什么filter？</p>
<p>ClassPathScanningCandidateComponentProvider#registerDefaultFilters 205</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerDefaultFilters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Component.class));</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(</span><br><span class="line">            ((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;) ClassUtils.forName(<span class="string">&quot;javax.annotation.ManagedBean&quot;</span>, cl)), <span class="literal">false</span>));</span><br><span class="line">        logger.trace(<span class="string">&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(</span><br><span class="line">            ((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;) ClassUtils.forName(<span class="string">&quot;javax.inject.Named&quot;</span>, cl)), <span class="literal">false</span>));</span><br><span class="line">        logger.trace(<span class="string">&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnnotationTypeFilter的父类AbstractTypeHierarchyTraversingFilter#match(MetadataReader,MetadataReaderFactory)方法</p>
<p>最后会到AnnotationTypeFilter#matchSelf方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">matchSelf</span><span class="params">(MetadataReader metadataReader)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line">    <span class="comment">// 包含指定的注解 或者 注解里面包含指定注解， 比如指定的@Componet注解，在@Service注解中有包含</span></span><br><span class="line">    <span class="keyword">return</span> metadata.hasAnnotation(<span class="built_in">this</span>.annotationType.getName()) ||</span><br><span class="line">        (<span class="built_in">this</span>.considerMetaAnnotations &amp;&amp; metadata.hasMetaAnnotation(<span class="built_in">this</span>.annotationType.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Configuration、@Controller、@Service、@Repository注解中类似@Service，都包含@Component注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 包含Component注解，类似继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">	 * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考</strong></p>
<ul>
<li><p>我们可以自己定义标注组件的注解吗？【扩展点】</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-meta-annotations">https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-meta-annotations</a></p>
</li>
<li><p>扫描的过滤这块你在实际项目中是否用过？如何使用的？【扩展点】</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-scanning-filters">https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-scanning-filters</a></p>
<p>TypeFilter的实现类<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823133942.png"></p>
<p>自定义实现TypeFilter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title class_">TypeFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用metadataReader中的类信息、注解信息来进行你的过滤判断逻辑</span></span><br><span class="line">        <span class="keyword">return</span> metadataReader.getClassMetadata().getClassName().equals(GarfieldCat.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Controller注解，它和@Service、@Component注解有不同的意图，这种不同的意图将会在哪里实现？如果我们自己也有类似的需求自定义组件注解，是不就可以模仿@Controller。猜想spring是如何实现灵活扩展的？</p>
</li>
<li><p>为何ScannedGrenericBeanDefinition没有提取依赖注入相关的信息？这些为什么现在不提取？会在什么时候提取？<br>ClassPathBeanDefinitionScanner#scan(String[])</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            <span class="comment">// 设置bean的作用域</span></span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// 设置bean的默认配置以及是否作为候选bean配置</span></span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// 设置bean的LazyInit、Primary、DependsOn、Role、Description配置</span></span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">                <span class="comment">// 为所提供的目标bean生成作用域代理，使用内部名称注册目标bean并在作用域代理上设置“targetBeanName”。</span></span><br><span class="line">                definitionHolder =</span><br><span class="line">                    AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Bean定义的注册逻辑"><a href="#Bean定义的注册逻辑" class="headerlink" title="Bean定义的注册逻辑"></a>Bean定义的注册逻辑</h2><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p>BeanDefinitionReaderUtils#registerBeanDefinition方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    <span class="comment">// 通过bean工厂注册bean定义</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    <span class="comment">// 给beanName和别名绑定</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><p>DefaultListableBeanFactory#registerBeanDefinition方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 如果有继承自AbstractBeanDefinition，则先对Bean定义进行校验</span></span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                                                   <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 是否已经存在相关Bean定义，先进行判断</span></span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123; <span class="comment">// 2.1 beanName的Bean定义已经存在的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123; <span class="comment">// 2.1.1 不允许重写覆盖，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125; <span class="comment">// 2.1.2 允许重写覆盖的处理，进行一些日志信息的打印，告知处理的信息</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                            <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                            existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                             <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                             <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.1.3 覆盖原有的Bean定义</span></span><br><span class="line">        <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.2 beanName的Bean定义不存在的情况处理</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.2.1 当前Bean对象是否正在创建</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="comment">// 2.2.1.1 启动期间，同步处理，防止其他地方集合的迭代异常</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="comment">// 使用ConcurrentHashMap进行存储</span></span><br><span class="line">                <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 2.2.2 当前bean还没有开始创建，直接put</span></span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 如果对应的单例bean存在，则重置这个Bean</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要冻结配置，清除类型映射缓存</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="别名处理"><a href="#别名处理" class="headerlink" title="别名处理"></a>别名处理</h3><p>将别名作为Key，beanName作为Value进行map存储，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerAlias</span><span class="params">(String name, String alias)</span> &#123;</span><br><span class="line">    Assert.hasText(name, <span class="string">&quot;&#x27;name&#x27; must not be empty&quot;</span>);</span><br><span class="line">    Assert.hasText(alias, <span class="string">&quot;&#x27;alias&#x27; must not be empty&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.aliasMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.aliasMap.remove(alias);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Alias definition &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; ignored since it points to same name&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">registeredName</span> <span class="operator">=</span> <span class="built_in">this</span>.aliasMap.get(alias);</span><br><span class="line">            <span class="keyword">if</span> (registeredName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">                    <span class="comment">// An existing alias - no need to re-register</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot define alias &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; for name &#x27;&quot;</span> +</span><br><span class="line">                                                    name + <span class="string">&quot;&#x27;: It is already registered for name &#x27;&quot;</span> + registeredName + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Overriding alias &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; definition for registered name &#x27;&quot;</span> +</span><br><span class="line">                                 registeredName + <span class="string">&quot;&#x27; with new target name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            checkForAliasCircle(name, alias);</span><br><span class="line">            <span class="built_in">this</span>.aliasMap.put(alias, name);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Alias definition &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; registered for name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


















      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/02-Spring/06-Spring%E6%BA%90%E7%A0%81-Bean%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" data-id="clmcxecsy006yu8wa9hcv34j4" data-title="Spring源码-Bean定义加载过程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-02-Spring/07-Spring源码-IOC容器核心流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/02-Spring/07-Spring%E6%BA%90%E7%A0%81-IOC%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/02-Spring/07-Spring%E6%BA%90%E7%A0%81-IOC%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/">Spring源码-IOC容器核心流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="IOC容器核心流程"><a href="#IOC容器核心流程" class="headerlink" title="IOC容器核心流程"></a>IOC容器核心流程</h1><p>Spring IOC容器核心方法在于Refresh方法，这个方法里面完成了Spring初始化、准备Bean、实例化Bean及扩展功能的实现。所以学明白它非常重要。</p>
<h2 id="带着问题"><a href="#带着问题" class="headerlink" title="带着问题"></a>带着问题</h2><ol>
<li><p>这个方法做什么用的？</p>
</li>
<li><p>它是怎么完成这个功能的？</p>
</li>
<li><p>为什么要这样实现？</p>
</li>
<li><p>有哪些值得学习借鉴的地方？</p>
</li>
</ol>
<h2 id="Refresh方法"><a href="#Refresh方法" class="headerlink" title="Refresh方法"></a>Refresh方法</h2><ul>
<li><p>在哪里定义的？<br>ConfigurableApplicationContext#refresh</p>
<p>这个方法用来加载刷新配置，这些配置可能来自，java配置、xml文件、properties文件，关系型数据库，或者其他格式。</p>
<p>作为一个启动方法，它应当在初始化失败后销毁已经创建了的单例，防止占着资源不用。也就是说调用这个方法，要么所有的单例被创建、要么没有单例对象创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load or refresh the persistent representation of the configuration, which</span></span><br><span class="line"><span class="comment"> * might be from Java-based configuration, an XML file, a properties file, a</span></span><br><span class="line"><span class="comment"> * relational database schema, or some other format.</span></span><br><span class="line"><span class="comment"> * 这个方法用来加载刷新配置，这些配置可能来自，java配置、xml文件、properties文件，关系型数据库，或者其他格式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As this is a startup method, it should destroy already created singletons</span></span><br><span class="line"><span class="comment"> * if it fails, to avoid dangling resources. In other words, after invocation</span></span><br><span class="line"><span class="comment"> * of this method, either all or no singletons at all should be instantiated.</span></span><br><span class="line"><span class="comment"> * 作为一个启动方法，它应当在初始化失败后销毁已经创建了的单例，防止占着资源不用。</span></span><br><span class="line"><span class="comment"> * 也就是说调用这个方法，要么所有的单例被创建、要么没有单例对象创建。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean factory could not be initialized Bean工厂不能被初始化，抛出BeansException异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if already initialized and multiple refresh</span></span><br><span class="line"><span class="comment"> * attempts are not supported bean工厂已经被初始化了，但是不支持多次刷新，抛出IllegalStateException异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException;</span><br></pre></td></tr></table></figure>

<p>经过对该方法的注解解读，发现该方法提供了从加载配置单例bean创建的功能。</p>
</li>
<li><p>在哪里实现的？<br>AbstractApplicationContext#refresh</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">//1 Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 为什么要从子类获得刷新后的BeanFactory？</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//4 Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5 Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6 Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//7 Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//8 Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//9 Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//10 Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//11 Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//12 Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//13 Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AbstractApplicationContext中的实现，调用了10多个方法，来完成该功能。</p>
</li>
<li><p>哪些类使用？<br>打开ConfigurableApplicationContext#refresh方法，Alt+F7就能找到相关调用方法的地方，可以看到基本都在ApplicationContext的实现子类中使用。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823164411.png"></p>
<p>用法示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了new各种ApplicationContext实现子类，还可以手动调用</span></span><br><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">cac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">gac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(gac).loadBeanDefinitions(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(gac).scan(<span class="string">&quot;com.study.spring&quot;</span>);</span><br><span class="line"><span class="comment">// 一定要刷新</span></span><br><span class="line">gac.refresh();</span><br></pre></td></tr></table></figure>

<p>refresh方法有13个方法一定会被调用到，这里也就包含了13个步骤逻辑，接下来逐一进行分析。</p>
</li>
</ul>
<h2 id="IOC容器刷新整体流程"><a href="#IOC容器刷新整体流程" class="headerlink" title="IOC容器刷新整体流程"></a>IOC容器刷新整体流程</h2><p>这13个方法中，每一个方法都是一个步骤。</p>
<p>梳理如图：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823165040.png"></p>
<p>整个流程如上图，其中最关键的在于下面的6个方法。</p>
<h2 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h2><p>告诉子类刷新内部的BeanFactory，其实就是配置用户属性、加载Bean定义，并返回刷新后的Bean工厂。refreshBeanFactory方法又由两个抽象方法构成，交给子类实现。也就是子类必定含有一个BeanFactory实例，并且还需要提供刷新方法、返回BeanFactory实例方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的实现有AbstractRefreshableApplicationContext、GenericApplicationContext两个类。</p>
<ul>
<li><p>AbstractRefreshableApplicationContext<br>AbstractRefreshableApplicationContext中实现的刷新方法，可以被多次调用执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;  <span class="comment">// 存在Bean工厂则销毁单例bean，释放资源</span></span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建DefalutListableBeanFactory实例</span></span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">        <span class="comment">// 设置ID</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 自定义Bean工厂属性：Bean定义重写、循环引用等配置</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 等待子类实现的，向bean工厂注册Bean定义</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="comment">// 持有bean工厂实例，以便在getBeanFactory方法中返回出去</span></span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean定义的加载注册前面已经学习过了，到这里就能过连上去了。</p>
</li>
<li><p>GenericApplicationContext<br>GenericApplicationContext中的刷新方法，只能被调用一次，被Atomic的refreshed状态控制着。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刷新的方法也很简单，只是设置了一个ID。那么此时应该有几个疑问。</p>
<ul>
<li>BeanFactory什么时候创建的？<br>构造函数中</li>
<li>此时的BeanFactory里面都有什么呢？<br>回头想想，注解方式的Bean定义加载过程都装载了什么。BeanFactoryPostProcessor、BeanPostProcessor、ApplicationListener。</li>
</ul>
</li>
</ul>
<h2 id="prepareBeanFacotry"><a href="#prepareBeanFacotry" class="headerlink" title="prepareBeanFacotry"></a>prepareBeanFacotry</h2><p>此时，Bean定义加载完成，Bean工厂已经被构建了，加下来做的事情就是给Bean工厂对象，注入执行后续东西需要的依赖，比如ClassLoader、BeanPostProcessor、环境相关的实例Bean。AbstractApplicationContext#prepareBeanFactory方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">    <span class="comment">// 给bean工作准备ClassLoader、SPL表达是解析器、属性编辑注册器等</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">    <span class="comment">// 向BeanFactory注册ApplicationContextAwareProcessor</span></span><br><span class="line">    <span class="comment">// 后面的6种Aware忽略它们的自动依赖注入，为什么？</span></span><br><span class="line">    <span class="comment">// 因为在ApplicationContextAwareProcessor中已经对这6种Aware进行了处理</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    <span class="comment">// 依赖需要使用的bean，IOC容器自己的多角色身份 @Autowried方式获得下列类型bean</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">	<span class="comment">// 注入ApplicationListeners接口实现的发现处理器，同时带有销毁、bean定义混合的实现。</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register default environment beans.</span></span><br><span class="line">    <span class="comment">// 这些参数的应用顺序是怎么样的？</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// properties配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 操作系统环境变量：JAVA_HOME等</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>BeanPostProcessor的注入<br>ApplicationContextAwareProcessor、ApplicationListenerDetector、LoadTimeWeaverAwareProcessor，查看其中一个。</p>
<p>ApplicationContextAwareProcessor中的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">          bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">          bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware))&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        acc = <span class="built_in">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acc != <span class="literal">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareInterfaces(bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;, acc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将beanFactory注入给上述的6种Aware</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareInterfaces</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">        ((EnvironmentAware) bean).setEnvironment(<span class="built_in">this</span>.applicationContext.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">        ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="built_in">this</span>.embeddedValueResolver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">        ((ResourceLoaderAware) bean).setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">        ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">        ((MessageSourceAware) bean).setMessageSource(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">        ((ApplicationContextAware) bean).setApplicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动注册环境相关单例Bean<br>environment、systemProperties、systemEnvironment</p>
</li>
</ul>
<h2 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h2><p>此时，bean工厂基本准备已经完成，但是Bean实例还未进行初始化，接下来，调用BeanFactoryPostProcessor对Bean工厂中的Bean定义进行调整。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 最重要的处理在委托里面实现</span></span><br><span class="line">    <span class="comment">// getBeanFactoryPostProcessors()获取的是容器里面的列表属性，这个属性没有机会给外部去注入BeanFactoryPostProcessor对象。因为ApplicationContext子类在构造函数中调用了refresh方法。所以这里是个空值。</span></span><br><span class="line">    <span class="comment">// 外部又是如何加入进去的呢？看看委托里面的实现</span></span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">    <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法解读</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时beanFactoryPostProcessors为空</span></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                <span class="comment">// BeanDefinitionRegistryPostProcessor似曾相识，在哪里看到过？</span></span><br><span class="line">                <span class="comment">// 对，就是ConfigurationClassPostProcessor，对@Configuration注解过的类进行处理</span></span><br><span class="line">                <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span></span><br><span class="line">                    (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">        <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">        <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            reiterate = <span class="literal">false</span>;</span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    reiterate = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">        beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">    <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IOC容器与BeanFactoryPostProcessor的关系</strong></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823100858.png"></p>
<ul>
<li><p>BeanFactoryPostProcessors的调用处理</p>
<p>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors分析</p>
<p>拆分处理：registryProcessors、regularPostProcessors</p>
<p>排序处理：PriorityOrdered、Ordered</p>
<p>多次调用BeanFactoryPostProcessors的分析：在调用BeanFactoryPostProcessors过程中，还会产生BeanFactoryPostProcessors，直到所有的BeanFactoryPostProcessors处理完毕。</p>
</li>
</ul>
<h2 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h2><p>此时Bean定义加载完成，Bean工厂完成了刷新实例化，通过了BeanFactoryProcessor修整了Bean定义，接下来注册BeanPostProcessors。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PostProcessorRegistrationDelegate.registerBeanPostProcessors</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line"></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">    <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">    <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">beanProcessorTargetCount</span> <span class="operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            priorityOrderedPostProcessors.add(pp);</span><br><span class="line">            <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        orderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        nonOrderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">    <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">    <span class="comment">// 之前在prepareBeanFacotry()中已经添加过为什么还要再次添加？</span></span><br><span class="line">    <span class="comment">// 重新注册用于检测内部bean的后处理器为applicationlistener，</span></span><br><span class="line">    <span class="comment">// 将它移动到处理器链的末端(用于拾取代理等)</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注册BeanPostProcessor的处理<br>整体处理逻辑与BeanFactroyPostProcessor的处理一样，排序然后调用的处理。</p>
<ol>
<li><p>priorityOrderedPostProcessors</p>
</li>
<li><p>orderedPostProcessors</p>
</li>
<li><p>nonOrderedPostProcessors</p>
</li>
<li><p>internalPostProcessors</p>
</li>
<li><p>ApplicationListenerDetector</p>
</li>
</ol>
</li>
</ul>
<h2 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h2><p>此时BenPostProcessor都已经注册完成，下一步准备资源国际化的事宜。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="comment">// 如果Bean工厂中存在名为messageSource的bean，则使用它</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">        <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">            <span class="type">HierarchicalMessageSource</span> <span class="variable">hms</span> <span class="operator">=</span> (HierarchicalMessageSource) <span class="built_in">this</span>.messageSource;</span><br><span class="line">            <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">                <span class="comment">// registered already.</span></span><br><span class="line">                hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用DelegatingMessageSource作为国际化资源处理bean</span></span><br><span class="line">        <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">        <span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line">        dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">        <span class="built_in">this</span>.messageSource = dms;</span><br><span class="line">        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="built_in">this</span>.messageSource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用示例<br>![image-20210824110226815](C:\Users\chen cheng\AppData\Roaming\Typora\typora-user-images\image-20210824110226815.png)</li>
</ul>
<h2 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h2><p>国际化资源准备完毕，接下来，检查事件监听器，并注册到事件传播器上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment"> * Doesn&#x27;t affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment"> * 在不生成Bean对象的情况下添加ApplicationListener bean作为监听器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">        getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">            getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>事件广播器执行方法<br>SimpleApplicationEventMulticaster#multicastEvent(ApplicationEvent, ResolvableType)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h2><p>完成bean工厂的初始化，将bean工厂中，非懒加载的单例bean进行实例化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the refresh of this context, invoking the LifecycleProcessor&#x27;s</span></span><br><span class="line"><span class="comment"> * onRefresh() method and publishing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">    clearResourceCaches();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">    initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">    getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish the final event.</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器的关闭"><a href="#容器的关闭" class="headerlink" title="容器的关闭"></a>容器的关闭</h2><p>AbstractApplicationContext#close</p>
<p>AbstractApplicationContext#registerShutdownHook</p>
<p>AbstractApplicationContext#doClose</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/02-Spring/07-Spring%E6%BA%90%E7%A0%81-IOC%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" data-id="clmcxect60071u8waebsv6wfj" data-title="Spring源码-IOC容器核心流程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ActiveMQ/">ActiveMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dubbo/">Dubbo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/K8s/">K8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kafka/">Kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RabbitMQ/">RabbitMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Socker/">Socker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Zookeeper/">Zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActiveMQ/" rel="tag">ActiveMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CDH/" rel="tag">CDH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/" rel="tag">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/" rel="tag">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KDTree/" rel="tag">KDTree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/" rel="tag">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/" rel="tag">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socker/" rel="tag">Socker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/" rel="tag">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YARN/" rel="tag">YARN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZooKeeper/" rel="tag">ZooKeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag">注解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" rel="tag">集合源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ActiveMQ/" style="font-size: 10px;">ActiveMQ</a> <a href="/tags/CDH/" style="font-size: 10px;">CDH</a> <a href="/tags/Docker/" style="font-size: 18px;">Docker</a> <a href="/tags/Dubbo/" style="font-size: 13px;">Dubbo</a> <a href="/tags/Golang/" style="font-size: 19px;">Golang</a> <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/K8s/" style="font-size: 10px;">K8s</a> <a href="/tags/KDTree/" style="font-size: 10px;">KDTree</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/MQ/" style="font-size: 10px;">MQ</a> <a href="/tags/MapReduce/" style="font-size: 10px;">MapReduce</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 14px;">Mybatis</a> <a href="/tags/Netty/" style="font-size: 14px;">Netty</a> <a href="/tags/RPC/" style="font-size: 11px;">RPC</a> <a href="/tags/RabbitMQ/" style="font-size: 15px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 17px;">Redis</a> <a href="/tags/Socker/" style="font-size: 10px;">Socker</a> <a href="/tags/Spark/" style="font-size: 11px;">Spark</a> <a href="/tags/Spring/" style="font-size: 20px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/Tomcat/" style="font-size: 13px;">Tomcat</a> <a href="/tags/YARN/" style="font-size: 11px;">YARN</a> <a href="/tags/ZooKeeper/" style="font-size: 12px;">ZooKeeper</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 16px;">多线程</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 10px;">注解</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 11px;">设计模式</a> <a href="/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" style="font-size: 13px;">集合源码</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/05-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/04-Sharding-JDBC%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/03-MyCat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/02-MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/01-MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>