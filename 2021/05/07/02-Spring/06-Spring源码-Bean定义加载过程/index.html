<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Spring源码-Bean定义加载过程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Bean定义加载过程解读 介绍BeanDefinition接口定义 介绍BeanDefinition的继承体系 XML方式Bean定义加载过程 注解方式Bean定义扫描过程  Bean定义详解BeanDefinition，bean定义的接口行为描述。 BeanDefinition接口中定义了Bean定义的相关行为，我们从中可看到很多熟悉的项。如对里面的信息项不熟，请查看代码的注释。同时请对比看xm">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码-Bean定义加载过程">
<meta property="og:url" content="http://example.com/2021/05/07/02-Spring/06-Spring%E6%BA%90%E7%A0%81-Bean%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Bean定义加载过程解读 介绍BeanDefinition接口定义 介绍BeanDefinition的继承体系 XML方式Bean定义加载过程 注解方式Bean定义扫描过程  Bean定义详解BeanDefinition，bean定义的接口行为描述。 BeanDefinition接口中定义了Bean定义的相关行为，我们从中可看到很多熟悉的项。如对里面的信息项不熟，请查看代码的注释。同时请对比看xm">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820100249.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820101354.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820103448.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820104125.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820105252.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820160144.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210822173738.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210822173903.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823092347.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823092647.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823093216.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823094149.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823100239.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823100858.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823101307.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823110241.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820101354.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823130243.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823130954.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823131653.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823131838.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823133942.png">
<meta property="article:published_time" content="2021-05-07T14:36:30.000Z">
<meta property="article:modified_time" content="2021-12-12T10:16:11.984Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820100249.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-02-Spring/06-Spring源码-Bean定义加载过程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/02-Spring/06-Spring%E6%BA%90%E7%A0%81-Bean%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T14:36:30.000Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Spring源码-Bean定义加载过程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Bean定义加载过程解读"><a href="#Bean定义加载过程解读" class="headerlink" title="Bean定义加载过程解读"></a>Bean定义加载过程解读</h1><ul>
<li>介绍BeanDefinition接口定义</li>
<li>介绍BeanDefinition的继承体系</li>
<li>XML方式Bean定义加载过程</li>
<li>注解方式Bean定义扫描过程</li>
</ul>
<h2 id="Bean定义详解"><a href="#Bean定义详解" class="headerlink" title="Bean定义详解"></a>Bean定义详解</h2><p>BeanDefinition，bean定义的接口行为描述。</p>
<p>BeanDefinition接口中定义了Bean定义的相关行为，我们从中可看到很多熟悉的项。如对里面的信息项不熟，请查看代码的注释。同时请对比看xml配置的dtd或xsd，在beans.jar中org.springframework.beans.factory.xml 包下：spring-beans.dtd 或 spring-beans.xsd。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A BeanDefinition describes a bean instance, which has property values, constructor argument values, and further information</span></span><br><span class="line"><span class="comment"> * supplied by concrete implementations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">AttributeAccessor</span>, BeanMetadataElement &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean定义接口的常用方法如下：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820100249.png"></p>
<h2 id="BeanDefinition继承体系"><a href="#BeanDefinition继承体系" class="headerlink" title="BeanDefinition继承体系"></a>BeanDefinition继承体系</h2><p>了解一下BeanDefinition的继承体系，看看它的实现类</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820101354.png"></p>
<p>在2.5前用RootBeanDefinition、ChildBeanDefinition。在2.5版本后新增了四个接口类，推荐使用，GenericBeanDefinition、AnnotatedGenericBeanDefinition两个类都是2.5版本后引入的类、接口。</p>
<table>
<thead>
<tr>
<th>父接口</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>AttributeAccessor</td>
<td>接口定义了用于向任意对象附加和访问元数据的通用契约。</td>
</tr>
<tr>
<td>BeanMetadataElement</td>
<td>接口由携带配置源对象的bean元数据元素实现。</td>
</tr>
</tbody></table>
<h2 id="BeanDefinitionRegistry-Bean定义注册"><a href="#BeanDefinitionRegistry-Bean定义注册" class="headerlink" title="BeanDefinitionRegistry Bean定义注册"></a>BeanDefinitionRegistry Bean定义注册</h2><p>Bean定义的信息最终注册到哪里去了呢？查看BeanDefinitionRegistry接口信息。</p>
<p>BeanDefinitionRegistry接口定义了bean定义信息的注册行为。BeanDefinitionRegistry中定义的行为：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820103448.png"></p>
<p><strong>BeanDefinitionRegistry继承体系</strong></p>
<p>通过BeanDefinitionRegistry的继承体系可以发现，SimpleBeanDefinitionRegistry、DefaultLlistableBeanFactory和GenericApplicationContext中实现了接口的方法，我们可以通过他们进行注册bean定义。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820104125.png"></p>
<p>查看GenericApplicationContext源码，它本质上是通过DefaultLlistableBeanFactory实例来完成Bean定义注册的。正在原生实现BeanDefinitionRegistry接口的只有两个类：SimpleBeanDefinitionRegistry、DefaultLlistableBeanFactory。在目前的环境中SimpleBeanDefinitionRegistry没有被使用到</p>
<h2 id="XML加载与解析"><a href="#XML加载与解析" class="headerlink" title="XML加载与解析"></a>XML加载与解析</h2><p>回顾前面的内容，XML资源加载流程如下</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820105252.png"></p>
<h3 id="调试分析XML加载方式"><a href="#调试分析XML加载方式" class="headerlink" title="调试分析XML加载方式"></a>调试分析XML加载方式</h3><ul>
<li><p>怎么动态调试分析？<br>找到关键点，Bean定义实现类GenericBeanDefinition#setBeanClassName，设置断点，并且设置条件。<br>“com.study.spring.bean.GarfieldCat”.equals(beanClassName)</p>
</li>
<li><p>如何进行分析？<br>保留调用栈，查看包、类、方法、输入输出的变化</p>
</li>
</ul>
<p>ClassPathXmlApplicationContext方式，参考示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 断点位置</span></span><br><span class="line">setBeanClassName:<span class="number">386</span>, AbstractBeanDefinition (org.springframework.beans.factory.support)</span><br><span class="line"><span class="comment">// 最终在BeanDefinitionReaderUtils中构建GenericBeanDefinition对象</span></span><br><span class="line">createBeanDefinition(String, String, ClassLoader):<span class="number">67</span>, BeanDefinitionReaderUtils (org.springframework.beans.factory.support) <span class="comment">/*BeanDefinition解析器*/</span></span><br><span class="line"><span class="comment">// 创建BeanDefinition对象</span></span><br><span class="line">createBeanDefinition(String, String):<span class="number">642</span>, BeanDefinitionParserDelegate (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 解析单个 &lt;bean/&gt; 节点，将相关属性装入BeanDefinition对象中</span></span><br><span class="line">parseBeanDefinitionElement(Element, String, BeanDefinition):<span class="number">515</span>, BeanDefinitionParserDelegate (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 构建BeanDefinitionHolder，能够处理别名情况</span></span><br><span class="line">parseBeanDefinitionElement(Element, BeanDefinition):<span class="number">437</span>, BeanDefinitionParserDelegate (org.springframework.beans.factory.xml) parseBeanDefinitionElement(Element):<span class="number">405</span>, BeanDefinitionParserDelegate (org.springframework.beans.factory.xml)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** BeanDefinitionReder-XmlBeanDefinitionReader 处理堆栈信息*/</span></span><br><span class="line"><span class="comment">// 获得BeanDefinitionHolder对象，并注入BeanFactory中</span></span><br><span class="line"><span class="comment">// 解析BeanDefinition中的参数属性值：BeanComponentDefinition</span></span><br><span class="line"><span class="comment">// 激活Reader中的组件注册事件</span></span><br><span class="line">processBeanDefinition(Element, BeanDefinitionParserDelegate):<span class="number">306</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 拆解xml中的默认各个元素节点：beans、bean、import、alias</span></span><br><span class="line">parseDefaultElement(Element, BeanDefinitionParserDelegate):<span class="number">197</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 从xml文件的根节点开始解析内容</span></span><br><span class="line"><span class="comment">// 拆解其他扩展元素 &lt;aop/&gt; &lt;config/&gt;由 parseCustomElement方法通过命名空间来完成</span></span><br><span class="line">parseBeanDefinitions(Element, BeanDefinitionParserDelegate):<span class="number">176</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册BeanDefinition过程：DefaultBeanDefinitionDocumentReader*/</span></span><br><span class="line"><span class="comment">// 正在开始进行xml 父节点拆解的方法</span></span><br><span class="line">doRegisterBeanDefinitions(Element):<span class="number">149</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// documentReader XML文档解读类进行解析xml文件</span></span><br><span class="line">registerBeanDefinitions(Document, XmlReaderContext):<span class="number">96</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 通过DefaultBeanDefinitionDocumentReader对象解读xml，并计算解析到的bean定义个数</span></span><br><span class="line">registerBeanDefinitions(Document, Resource):<span class="number">511</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// BeanDefinition资源加载过程：Resource解读为Document，解析Document</span></span><br><span class="line">doLoadBeanDefinitions(InputSource, Resource):<span class="number">391</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) loadBeanDefinitions(EncodedResource):<span class="number">338</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) loadBeanDefinitions(Resource):<span class="number">310</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 将多个资源进行循环解析加载</span></span><br><span class="line">loadBeanDefinitions(Resource[]):<span class="number">188</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String, Set):<span class="number">224</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String):<span class="number">195</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String[]):<span class="number">257</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IOC 容器加载堆栈 */</span></span><br><span class="line"><span class="comment">// 解读xml配置的关键转折点</span></span><br><span class="line">loadBeanDefinitions(XmlBeanDefinitionReader):<span class="number">128</span>, AbstractXmlApplicationContext (org.springframework.context.support)</span><br><span class="line"><span class="comment">// new XmlBeanDefinitionReader解读器对象，开始进入解读状态</span></span><br><span class="line">loadBeanDefinitions(DefaultListableBeanFactory):<span class="number">94</span>, AbstractXmlApplicationContext (org.springframework.context.support) refreshBeanFactory():<span class="number">130</span>, AbstractRefreshableApplicationContext (org.springframework.context.support)</span><br><span class="line">obtainFreshBeanFactory():<span class="number">638</span>, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh():<span class="number">523</span>, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;(String[], <span class="type">boolean</span>, ApplicationContext):<span class="number">144</span>,ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;(String):<span class="number">85</span>, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line"><span class="comment">// 启动类</span></span><br><span class="line">main(String[]):<span class="number">20</span>, Application (com.study)</span><br></pre></td></tr></table></figure>

<p>关键节点：</p>
<p><strong>ClassPathXmlApplicationContext</strong>.<init></p>
<p><strong>AbstractApplicationContext.refresh</strong> -&gt; obtainFreshBeanFactory -&gt; refreshBeanFactory</p>
<p><strong>AbstractXmlApplicationContext.loadBeanDefinitions</strong></p>
<p><strong>AbstractBeanDefinitionReader.loadBeanDefinitions</strong></p>
<p><strong>XmlBeanDefinitionReader.loadBeanDefinitions</strong> -&gt; doLoadBeanDefinitions -&gt; registerBeanDefinitions</p>
<p>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions -&gt; doRegisterBeanDefinitions -&gt; processBeanDefinition</p>
<p>BeanDefinitionParserDelegate.parseBeanDefinitionElement -&gt; createBeanDefinition</p>
<p>BeanDefinitionReaderUtils.createBeanDefinition</p>
<p>AbstractBeanDefinition.setBeanClassName</p>
<h3 id="XML的解析"><a href="#XML的解析" class="headerlink" title="XML的解析"></a>XML的解析</h3><p>关键流程在于Resource转Document转Element转成Bean定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** BeanDefinitionReder-XmlBeanDefinitionReader 处理堆栈信息*/</span></span><br><span class="line"><span class="comment">// 获得BeanDefinitionHolder对象，并注入BeanFactory中</span></span><br><span class="line"><span class="comment">// 解析BeanDefinition中的参数属性值：BeanComponentDefinition</span></span><br><span class="line"><span class="comment">// 激活Reader中的组件注册事件</span></span><br><span class="line">processBeanDefinition(Element, BeanDefinitionParserDelegate):<span class="number">306</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 拆解xml中的默认各个元素节点：beans、bean、import、alias</span></span><br><span class="line">parseDefaultElement(Element, BeanDefinitionParserDelegate):<span class="number">197</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 从xml文件的根节点开始解析内容</span></span><br><span class="line"><span class="comment">// 拆解其他扩展元素 &lt;aop/&gt; &lt;config/&gt;由 parseCustomElement方法通过命名空间来完成</span></span><br><span class="line">parseBeanDefinitions(Element, BeanDefinitionParserDelegate):<span class="number">176</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册BeanDefinition过程：DefaultBeanDefinitionDocumentReader*/</span></span><br><span class="line"><span class="comment">// 正在开始进行xml 父节点拆解的方法</span></span><br><span class="line">doRegisterBeanDefinitions(Element):<span class="number">149</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// documentReader XML文档解读类进行解析xml文件</span></span><br><span class="line">registerBeanDefinitions(Document, XmlReaderContext):<span class="number">96</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// 通过DefaultBeanDefinitionDocumentReader对象解读xml，并计算解析到的bean定义个数</span></span><br><span class="line">registerBeanDefinitions(Document, Resource):<span class="number">511</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)</span><br><span class="line"><span class="comment">// BeanDefinition资源加载过程：Resource解读为Document，解析Document</span></span><br><span class="line">doLoadBeanDefinitions(InputSource, Resource):<span class="number">391</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)</span><br></pre></td></tr></table></figure>

<h3 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h3><p>经过前面的分析，所有的Bean定义注册都将在DefaultListableBeanFactory.registerBeanDefinition方法执行，我们在这个地方打断点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必定经过的地方，进行埋伏，可以得到整个调用链 </span></span><br><span class="line">registerBeanDefinition(String, BeanDefinition):<span class="number">929</span>, DefaultListableBeanFactory (org.springframework.beans.factory.support) registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry):<span class="number">164</span>, BeanDefinitionReaderUtils (org.springframework.beans.factory.support) </span><br><span class="line">processBeanDefinition(Element, BeanDefinitionParserDelegate):<span class="number">311</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml) </span><br><span class="line"><span class="comment">// 后面都是加载解读XML的过程了，前面已经分析过了 </span></span><br><span class="line">parseDefaultElement(Element, BeanDefinitionParserDelegate):<span class="number">197</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml) </span><br><span class="line">parseBeanDefinitions(Element, BeanDefinitionParserDelegate):<span class="number">176</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml) </span><br><span class="line">doRegisterBeanDefinitions(Element):<span class="number">149</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml) registerBeanDefinitions(Document, XmlReaderContext):<span class="number">96</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml) </span><br><span class="line">registerBeanDefinitions(Document, Resource):<span class="number">511</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) doLoadBeanDefinitions(InputSource, Resource):<span class="number">391</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) loadBeanDefinitions(EncodedResource):<span class="number">338</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) loadBeanDefinitions(Resource):<span class="number">310</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml) loadBeanDefinitions(Resource[]):<span class="number">188</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String, Set):<span class="number">224</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String):<span class="number">195</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(String[]):<span class="number">257</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support) loadBeanDefinitions(XmlBeanDefinitionReader):<span class="number">128</span>, AbstractXmlApplicationContext (org.springframework.context.support) loadBeanDefinitions(DefaultListableBeanFactory):<span class="number">94</span>, AbstractXmlApplicationContext (org.springframework.context.support) refreshBeanFactory():<span class="number">130</span>, AbstractRefreshableApplicationContext (org.springframework.context.support) obtainFreshBeanFactory():<span class="number">638</span>, AbstractApplicationContext (org.springframework.context.support) </span><br><span class="line">refresh():<span class="number">523</span>, AbstractApplicationContext (org.springframework.context.support) </span><br><span class="line">&lt;init&gt;(String[], <span class="type">boolean</span>, ApplicationContext):<span class="number">144</span>, ClassPathXmlApplicationContext (org.springframework.context.support) </span><br><span class="line">&lt;init&gt;(String):<span class="number">85</span>, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">main(String[]):<span class="number">20</span>, Application (com.study)</span><br></pre></td></tr></table></figure>

<h3 id="Spring中扩展XML标签"><a href="#Spring中扩展XML标签" class="headerlink" title="Spring中扩展XML标签"></a>Spring中扩展XML标签</h3><p>在DefaultBeanDefinitionDocumentReader#parseBeanDefinitions(Element, BeanDefinitionParserDelegate)方法中的自定义标签解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不是默认的命名空间，扩展的标签交给代理进行处理</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinitionParserDelegate#parseCustomElement(Element, BeanDefinition) 方法内部实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得命名空间 URI</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceUri</span> <span class="operator">=</span> getNamespaceURI(ele);</span><br><span class="line">    <span class="keyword">if</span> (namespaceUri == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造命名空间处理器</span></span><br><span class="line">    <span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交给处理器解析</span></span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> <span class="title class_">ParserContext</span>(<span class="built_in">this</span>.readerContext, <span class="built_in">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820160144.png"></p>
<p>看看beans、context、aop jar包下的META-INF&#x2F;spring.handlers文件</p>
<p>xml中以后扩展标签，只需要添加配置、扩展实现类。实现功能即插即用，灵活扩展。</p>
<p><strong>请思考</strong>： </p>
<p>1、如果你需要加一个自己开发的模块（含自定义的bean定义标签）到spring中，你是否可以做到了。</p>
<p> 2、spring标签处理这里的设计：模块之间可以灵活组合，配置在各自的模块中，即插即用。</p>
<p>请大家自己定义一个模块，定义自定义配置标签，实现自己的NamespaceHandler，打包集成到spring中。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>XML方式最终是通过GenericBeanDefinition类进行Bean定义的装载</p>
<p>XML加载流程</p>
<p>ClassPathXmlApplicationContext.<init></p>
<p>AbstractApplicationContext.refresh -&gt; obtainFreshBeanFactory -&gt; refreshBeanFactory</p>
<p>AbstractXmlApplicationContext.loadBeanDefinitions</p>
<p>XML配置可以进行方便的扩展，类似Dubbo集成到Spring中那样</p>
<p>最终所有的Bean定义都是通过DefaultListableBeanFactory注册到Bean工厂</p>
<h2 id="注解扫描过程解读"><a href="#注解扫描过程解读" class="headerlink" title="注解扫描过程解读"></a>注解扫描过程解读</h2><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><p>经过前面的学习，知道入口为AnnotationConfigApplicationContext类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.study.spring.bean&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;hash&quot;</span>);</span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们该在哪里拦截分析？DefaultListableBeanFactory.registerBeanDefinition方法</p>
<h3 id="注解的加载处理"><a href="#注解的加载处理" class="headerlink" title="注解的加载处理"></a>注解的加载处理</h3><p>AnnotationConfigApplicationContext，在构造函数中构建了AnnotatedBeanDefinitionReader、ClassPathBeanDefinitionScanner对象。</p>
<p>注解准备工作，初始化注解处理组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 往bean工厂中注册【注解处理器】的bean定义</span></span><br><span class="line">registerBeanDefinition(String, BeanDefinition):<span class="number">929</span>, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">registerBeanDefinition(String, BeanDefinition):<span class="number">323</span>, GenericApplicationContext (org.springframework.context.support)</span><br><span class="line"><span class="comment">//  3. 通过方法名，注册注解配置的Processor，注册到内部BeanFactory中。是什么Processor呢？</span></span><br><span class="line">registerPostProcessor(BeanDefinitionRegistry, RootBeanDefinition, String):<span class="number">216</span>, AnnotationConfigUtils (org.springframework.context.annotation)</span><br><span class="line">registerAnnotationConfigProcessors(BeanDefinitionRegistry, Object):<span class="number">166</span>, AnnotationConfigUtils (org.springframework.context.annotation)</span><br><span class="line">registerAnnotationConfigProcessors(BeanDefinitionRegistry):<span class="number">137</span>, AnnotationConfigUtils (org.springframework.context.annotation)</span><br><span class="line"><span class="comment">// 2. 初始化 AnnotatedBeanDefinitionReader 对象</span></span><br><span class="line">&lt;init&gt;(BeanDefinitionRegistry, Environment):<span class="number">88</span>, AnnotatedBeanDefinitionReader (org.springframework.context.annotation)</span><br><span class="line">&lt;init&gt;(BeanDefinitionRegistry):<span class="number">71</span>, AnnotatedBeanDefinitionReader (org.springframework.context.annotation)</span><br><span class="line"><span class="comment">// 1. 执行AnnotationConfigApplicationContext的构造函数</span></span><br><span class="line">&lt;init&gt;():<span class="number">66</span>, AnnotationConfigApplicationContext (org.springframework.context.annotation)</span><br><span class="line">&lt;init&gt;(String[]):<span class="number">99</span>, AnnotationConfigApplicationContext (org.springframework.context.annotation)</span><br><span class="line"><span class="comment">// 0. 启动类</span></span><br><span class="line">main(String[]):<span class="number">9</span>, AnnotationConfig (com.study.spring.runner)</span><br></pre></td></tr></table></figure>

<p>注册的怎么不是我们的Bean定义而是Processor呢？</p>
<p>在这个调用栈中，我们并发没有看到它做包扫描的相关工作。从下往上看这个执行栈，点第2个，我们来</p>
<p>看看代码：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210822173738.png"></p>
<p>通过前面的学习，这里还没有扫描我们指定的包 basePackages，还只是ApplicationContext的初始化函数中。扫描在第二步 scan方法中，第三步才会refresh。也就是跟xml有点不一样，在构造函数中就开始了各种初始化准备。</p>
<p>它现在是在做一些初始化的准备处理，从这里我们获知，它做了registerAnnotationConfigProcessors。从名字上理解就是注册了一些注解配置的处理器。到底是一些什么processors，点方法进去看看：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210822173903.png"></p>
<p>注册所有相关的注解 post processor给registry，进入方法查看相关代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 上面的一段我们可以不用了解，跟我们的目标不符合</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将需要用到的各种处理器编制成Bean定义，好注入到工厂中，作为bean使用。</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">	<span class="comment">// 重点看下面的注册相关的代码</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// ConfigurationClassPostProcessor.class，@Configuration注解类后置处理器</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// AutowiredAnnotationBeanPostProcessor.class</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// CommonAnnotationBeanPostProcessor.class 通用注解后置处理器</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="comment">// 如果有JPA的支持，则加入相关的注解处理器</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                                                AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;Cannot load optional framework class: &quot;</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 最终返回各种处理器的bean定义列表</span></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来除了我们自己的应用bean，Spring自己内部也有各种bean注入到工厂，用来处理各种逻辑，比如这里的注解Bean定义的相关处理对象，都是通过Bean定义注入Bean工厂的。</p>
<p>这么多的processor，都是些什么Processor？点第一个的类名ConfigurationClassPostProcessor进去看看。</p>
<h4 id="BeanFactoryPostProcessor作用"><a href="#BeanFactoryPostProcessor作用" class="headerlink" title="BeanFactoryPostProcessor作用"></a>BeanFactoryPostProcessor作用</h4><ul>
<li><p>ConfigurationClassPostProcessor接口</p>
<p>看注释，启动阶段用来处理@Configuration注解的BeanFactoryPostProcessor，但是没有看到BeanFactoryPostProcessor接口的继承，但是有一个BeanDefinitionRegistryPostProcessor。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823092347.png"></p>
</li>
<li><p>ConfigurationClassPostProcessor的继承结构</p>
<p>通过IDE查看继承体系结构，果不然，它的爷爷就是BeanFactoryPostProcessor。 </p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823092647.png"></p>
<p>BeanDefinitionRegistryPostProcessor扩展了BeanFactoryPostProcessor，增加了BeanDefinitionRegistry位置的处理，即它可以提前对注册好的BeanDefinitionRegistry进行前置处理。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823093216.png"></p>
<p>BeanFactoryPostProcessor到底用来做什么的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory hook that allows for custom modification of an application context&#x27;s</span></span><br><span class="line"><span class="comment"> * bean definitions, adapting the bean property values of the context&#x27;s underlying</span></span><br><span class="line"><span class="comment"> * bean factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Useful for custom config files targeted at system administrators that</span></span><br><span class="line"><span class="comment"> * override bean properties configured in the application context. See</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> PropertyResourceConfigurer&#125; and its concrete implementations for</span></span><br><span class="line"><span class="comment"> * out-of-the-box solutions that address such configuration needs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125; may interact with and modify bean</span></span><br><span class="line"><span class="comment"> * definitions, but never bean instances. Doing so may cause premature bean</span></span><br><span class="line"><span class="comment"> * instantiation, violating the container and causing unintended side-effects.</span></span><br><span class="line"><span class="comment"> * If bean instance interaction is required, consider implementing</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BeanPostProcessor&#125; instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Registration&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An &#123;<span class="doctag">@code</span> ApplicationContext&#125; auto-detects &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * beans in its bean definitions and applies them before any other beans get created.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125; may also be registered programmatically</span></span><br><span class="line"><span class="comment"> * with a &#123;<span class="doctag">@code</span> ConfigurableApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Ordering&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125; beans that are autodetected in an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ApplicationContext&#125; will be ordered according to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.PriorityOrdered&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.Ordered&#125; semantics. In contrast,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125; beans that are registered programmatically</span></span><br><span class="line"><span class="comment"> * with a &#123;<span class="doctag">@code</span> ConfigurableApplicationContext&#125; will be applied in the order of</span></span><br><span class="line"><span class="comment"> * registration; any ordering semantics expressed through implementing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> PriorityOrdered&#125; or &#123;<span class="doctag">@code</span> Ordered&#125; interface will be ignored for</span></span><br><span class="line"><span class="comment"> * programmatically registered post-processors. Furthermore, the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.annotation.Order <span class="doctag">@Order</span>&#125; annotation is not</span></span><br><span class="line"><span class="comment"> * taken into account for &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125; beans.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam Brannen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 06.07.2003</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> PropertyResourceConfigurer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 所有的Bean定义加载完成，还未进行实例化前，对BeanFactory中的bean定义可进行想要做的处理。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment">	 * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment">	 * will have been instantiated yet. This allows for overriding or adding</span></span><br><span class="line"><span class="comment">	 * properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它对应的实现有PropertyResourceConfigurer、EventListenerMethodProcessor等，见图。<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823094149.png"></p>
<p>那么此时我们明白了这些Processor的作用，这样用Spring注解配置的类，都能通过这些ProcessorBean对象来进行处理相关的逻辑了。</p>
<p>这是springIOC中给我们提供的又一个【扩展点】，让我们可以在beanFactory开始创建Bean实例前对beanFactory进行一些处理。我们可以来试试：</p>
<p>自己实现一个BeanFactoryPostProcessor： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span> + <span class="string">&quot; 工作了..................................&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.study.spring.bean&quot;</span>, <span class="string">&quot;com.study.spring.ext&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;hash&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在哪里创建并执行的这个MyBeanFactoryPostProcessor？</p>
<p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823100239.png"></p>
<p>如果想了解其他的BeanFactoryPostProcessor都干了些什么，在它的实现方法里面打上断点进行调试。</p>
<p><strong>IOC容器与BeanFactoryPostProcessor的关系</strong><br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823100858.png"></p>
</li>
</ul>
<h3 id="注解的扫描"><a href="#注解的扫描" class="headerlink" title="注解的扫描"></a>注解的扫描</h3><p>接下来，我们看看注解的扫描过程，添加断点<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823101307.png"></p>
<p>到此处然后释放拦截，到DefaultListableBeanFactory.registerBeanDefinition断点得到调用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成bean定义到bean工厂的注册</span></span><br><span class="line">registerBeanDefinition(String, BeanDefinition):<span class="number">929</span>, DefaultListableBeanFactory (org.springframework.beans.factory.support)</span><br><span class="line">registerBeanDefinition(String, BeanDefinition):<span class="number">323</span>, GenericApplicationContext (org.springframework.context.support)</span><br><span class="line">registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry):<span class="number">164</span>, BeanDefinitionReaderUtils (org.springframework.beans.factory.support)</span><br><span class="line">registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry):<span class="number">320</span>, ClassPathBeanDefinitionScanner (org.springframework.context.annotation)</span><br><span class="line"><span class="comment">// 完成包名下的Bean定义扫描</span></span><br><span class="line">doScan(String[]):<span class="number">292</span>, ClassPathBeanDefinitionScanner (org.springframework.context.annotation)</span><br><span class="line"><span class="comment">// 构建并初始化ClassPathBeanDefinitionScanner扫描器对象，开始进行扫描</span></span><br><span class="line">scan(String[]):<span class="number">254</span>, ClassPathBeanDefinitionScanner (org.springframework.context.annotation)</span><br><span class="line">scan(String[]):<span class="number">176</span>, AnnotationConfigApplicationContext (org.springframework.context.annotation)</span><br><span class="line">&lt;init&gt;(String[]):<span class="number">100</span>, AnnotationConfigApplicationContext (org.springframework.context.annotation)</span><br><span class="line">main(String[]):<span class="number">9</span>, AnnotationConfig (com.study.spring.runner)</span><br></pre></td></tr></table></figure>

<p>从调用栈上我们可看到有哪些类参与进来，在哪里发生的什么。</p>
<p>找到ClassPathBeanDefinitionScanner#doScan方法，设置断点进行分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Perform a scan within the specified base packages,</span></span><br><span class="line"><span class="comment"> * returning the registered bean definitions.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor</span></span><br><span class="line"><span class="comment"> * but rather leaves this up to the caller.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePackages the packages to check for annotated classes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> set of beans registered if any for tooling registration purposes (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">	Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 1 遍历要扫描的包</span></span><br><span class="line">	<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">// 2 找到指定包下所有候选组件（配置的bean）</span></span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">		<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">			<span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">			candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">			<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">				postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">				AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">				<span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">				definitionHolder =</span><br><span class="line">						AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">				beanDefinitions.add(definitionHolder);</span><br><span class="line">                <span class="comment">// 3 注册bean定义到BeanFactory中</span></span><br><span class="line">				registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，真正完成的Bean定义的扫描工作，进入findCandidateComponents方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan the class path for candidate components.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePackage the package to check for annotated classes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a corresponding Set of autodetected bean definitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title function_">findCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">	<span class="comment">// 这段代码的逻辑：如果有组件索引并且索引支持包含的filters，就从组件索引中获取获选组件</span></span><br><span class="line">    <span class="comment">// 组件索引是什么？</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.componentsIndex != <span class="literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">		<span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="built_in">this</span>.componentsIndex, basePackage);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，进行类目录下指定包的扫描</span></span><br><span class="line">		<span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件索引请阅读：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/core.html#beans-scanning-index">https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/core.html#beans-scanning-index</a></p>
<h4 id="扫描执行"><a href="#扫描执行" class="headerlink" title="扫描执行"></a>扫描执行</h4><p>接下来查看，包下类执行扫描的方法：</p>
<p>ClassPathScanningCandidateComponentProvider#scanCandidateComponents，重点代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建扫描包的路径表达式，类似切点表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">            resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">        <span class="comment">// ResourcePatternResolver扫描包获取到.class文件</span></span><br><span class="line">        <span class="comment">// 扫描的逻辑：在包下找.class文件，这里要求能够灵活指定包，就需要用到模式匹配</span></span><br><span class="line">        <span class="comment">// 默认用到的Ant Path模式匹配，如指定的包 com.study.**.service</span></span><br><span class="line">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">	<span class="comment">// ...... 省略一堆代码</span></span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入getResourcePatternResolver方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ResourcePatternResolver <span class="title function_">getResourcePatternResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.resourcePatternResolver == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourcePatternResolver = <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.resourcePatternResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  能将指定的资源位置路径解析为一个或多个匹配的资源。可以是一对一的资源指定，也可以是一对多的匹配模式，通过ant path格式、classpath*:前缀。</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> ResourcePatternResolver&#125; implementation that is able to resolve a</span></span><br><span class="line"><span class="comment"> * specified resource location path into one or more matching Resources.</span></span><br><span class="line"><span class="comment"> * The source path may be a simple path which has a one-to-one mapping to a</span></span><br><span class="line"><span class="comment"> * target &#123;<span class="doctag">@link</span> org.springframework.core.io.Resource&#125;, or alternatively</span></span><br><span class="line"><span class="comment"> * may contain the special &quot;&#123;<span class="doctag">@code</span> classpath*:&#125;&quot; prefix and/or</span></span><br><span class="line"><span class="comment"> * internal Ant-style regular expressions (matched using Spring&#x27;s</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.util.AntPathMatcher&#125; utility).</span></span><br><span class="line"><span class="comment"> * Both of the latter are effectively wildcards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;No Wildcards:&lt;/b&gt; 无通配符模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In the simple case, if the specified location path does not start with the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> &quot;classpath*:&#125;&quot; prefix, and does not contain a PathMatcher pattern,</span></span><br><span class="line"><span class="comment"> * this resolver will simply return a single resource via a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> getResource()&#125; call on the underlying &#123;<span class="doctag">@code</span> ResourceLoader&#125;.</span></span><br><span class="line"><span class="comment"> * Examples are real URLs such as &quot;&#123;<span class="doctag">@code</span> file:C:/context.xml&#125;&quot;, pseudo-URLs</span></span><br><span class="line"><span class="comment"> * such as &quot;&#123;<span class="doctag">@code</span> classpath:/context.xml&#125;&quot;, and simple unprefixed paths</span></span><br><span class="line"><span class="comment"> * such as &quot;&#123;<span class="doctag">@code</span> /WEB-INF/context.xml&#125;&quot;. The latter will resolve in a</span></span><br><span class="line"><span class="comment"> * fashion specific to the underlying &#123;<span class="doctag">@code</span> ResourceLoader&#125; (e.g.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ServletContextResource&#125; for a &#123;<span class="doctag">@code</span> WebApplicationContext&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Ant-style Patterns:&lt;/b&gt;  ant风格模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;When the path location contains an Ant-style pattern, e.g.:</span></span><br><span class="line"><span class="comment"> * &lt;pre class=&quot;code&quot;&gt;</span></span><br><span class="line"><span class="comment"> * /WEB-INF/*-context.xml</span></span><br><span class="line"><span class="comment"> * com/mycompany/**&amp;#47;applicationContext.xml</span></span><br><span class="line"><span class="comment"> * file:C:/some/path/*-context.xml</span></span><br><span class="line"><span class="comment"> * classpath:com/mycompany/**&amp;#47;applicationContext.xml&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * the resolver follows a more complex but defined procedure to try to resolve</span></span><br><span class="line"><span class="comment"> * the wildcard. It produces a &#123;<span class="doctag">@code</span> Resource&#125; for the path up to the last</span></span><br><span class="line"><span class="comment"> * non-wildcard segment and obtains a &#123;<span class="doctag">@code</span> URL&#125; from it. If this URL is</span></span><br><span class="line"><span class="comment"> * not a &quot;&#123;<span class="doctag">@code</span> jar:&#125;&quot; URL or container-specific variant (e.g.</span></span><br><span class="line"><span class="comment"> * &quot;&#123;<span class="doctag">@code</span> zip:&#125;&quot; in WebLogic, &quot;&#123;<span class="doctag">@code</span> wsjar&#125;&quot; in WebSphere&quot;, etc.),</span></span><br><span class="line"><span class="comment"> * then a &#123;<span class="doctag">@code</span> java.io.File&#125; is obtained from it, and used to resolve the</span></span><br><span class="line"><span class="comment"> * wildcard by walking the filesystem. In the case of a jar URL, the resolver</span></span><br><span class="line"><span class="comment"> * either gets a &#123;<span class="doctag">@code</span> java.net.JarURLConnection&#125; from it, or manually parses</span></span><br><span class="line"><span class="comment"> * the jar URL, and then traverses the contents of the jar file, to resolve the</span></span><br><span class="line"><span class="comment"> * wildcards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Implications on portability:&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the specified path is already a file URL (either explicitly, or</span></span><br><span class="line"><span class="comment"> * implicitly because the base &#123;<span class="doctag">@code</span> ResourceLoader&#125; is a filesystem one,</span></span><br><span class="line"><span class="comment"> * then wildcarding is guaranteed to work in a completely portable fashion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the specified path is a classpath location, then the resolver must</span></span><br><span class="line"><span class="comment"> * obtain the last non-wildcard path segment URL via a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Classloader.getResource()&#125; call. Since this is just a</span></span><br><span class="line"><span class="comment"> * node of the path (not the file at the end) it is actually undefined</span></span><br><span class="line"><span class="comment"> * (in the ClassLoader Javadocs) exactly what sort of a URL is returned in</span></span><br><span class="line"><span class="comment"> * this case. In practice, it is usually a &#123;<span class="doctag">@code</span> java.io.File&#125; representing</span></span><br><span class="line"><span class="comment"> * the directory, where the classpath resource resolves to a filesystem</span></span><br><span class="line"><span class="comment"> * location, or a jar URL of some sort, where the classpath resource resolves</span></span><br><span class="line"><span class="comment"> * to a jar location. Still, there is a portability concern on this operation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a jar URL is obtained for the last non-wildcard segment, the resolver</span></span><br><span class="line"><span class="comment"> * must be able to get a &#123;<span class="doctag">@code</span> java.net.JarURLConnection&#125; from it, or</span></span><br><span class="line"><span class="comment"> * manually parse the jar URL, to be able to walk the contents of the jar,</span></span><br><span class="line"><span class="comment"> * and resolve the wildcard. This will work in most environments, but will</span></span><br><span class="line"><span class="comment"> * fail in others, and it is strongly recommended that the wildcard</span></span><br><span class="line"><span class="comment"> * resolution of resources coming from jars be thoroughly tested in your</span></span><br><span class="line"><span class="comment"> * specific environment before you rely on it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;&#123;<span class="doctag">@code</span> classpath*:&#125; Prefix:&lt;/b&gt; classpath*:前缀的模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There is special support for retrieving multiple class path resources with</span></span><br><span class="line"><span class="comment"> * the same name, via the &quot;&#123;<span class="doctag">@code</span> classpath*:&#125;&quot; prefix. For example,</span></span><br><span class="line"><span class="comment"> * &quot;&#123;<span class="doctag">@code</span> classpath*:META-INF/beans.xml&#125;&quot; will find all &quot;beans.xml&quot;</span></span><br><span class="line"><span class="comment"> * files in the class path, be it in &quot;classes&quot; directories or in JAR files.</span></span><br><span class="line"><span class="comment"> * This is particularly useful for autodetecting config files of the same name</span></span><br><span class="line"><span class="comment"> * at the same location within each jar file. Internally, this happens via a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassLoader.getResources()&#125; call, and is completely portable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &quot;classpath*:&quot; prefix can also be combined with a PathMatcher pattern in</span></span><br><span class="line"><span class="comment"> * the rest of the location path, for example &quot;classpath*:META-INF/*-beans.xml&quot;.</span></span><br><span class="line"><span class="comment"> * In this case, the resolution strategy is fairly simple: a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassLoader.getResources()&#125; call is used on the last non-wildcard</span></span><br><span class="line"><span class="comment"> * path segment to get all the matching resources in the class loader hierarchy,</span></span><br><span class="line"><span class="comment"> * and then off each resource the same PathMatcher resolution strategy described</span></span><br><span class="line"><span class="comment"> * above is used for the wildcard subpath.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Other notes:&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;WARNING:&lt;/b&gt; Note that &quot;&#123;<span class="doctag">@code</span> classpath*:&#125;&quot; when combined with</span></span><br><span class="line"><span class="comment"> * Ant-style patterns will only work reliably with at least one root directory</span></span><br><span class="line"><span class="comment"> * before the pattern starts, unless the actual target files reside in the file</span></span><br><span class="line"><span class="comment"> * system. This means that a pattern like &quot;&#123;<span class="doctag">@code</span> classpath*:*.xml&#125;&quot; will</span></span><br><span class="line"><span class="comment"> * &lt;i&gt;not&lt;/i&gt; retrieve files from the root of jar files but rather only from the</span></span><br><span class="line"><span class="comment"> * root of expanded directories. This originates from a limitation in the JDK&#x27;s</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ClassLoader.getResources()&#125; method which only returns file system</span></span><br><span class="line"><span class="comment"> * locations for a passed-in empty String (indicating potential roots to search).</span></span><br><span class="line"><span class="comment"> * This &#123;<span class="doctag">@code</span> ResourcePatternResolver&#125; implementation is trying to mitigate the</span></span><br><span class="line"><span class="comment"> * jar root lookup limitation through &#123;<span class="doctag">@link</span> URLClassLoader&#125; introspection and</span></span><br><span class="line"><span class="comment"> * &quot;java.class.path&quot; manifest evaluation; however, without portability guarantees.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;WARNING:&lt;/b&gt; Ant-style patterns with &quot;classpath:&quot; resources are not</span></span><br><span class="line"><span class="comment"> * guaranteed to find matching resources if the root package to search is available</span></span><br><span class="line"><span class="comment"> * in multiple class path locations. This is because a resource such as</span></span><br><span class="line"><span class="comment"> * &lt;pre class=&quot;code&quot;&gt;</span></span><br><span class="line"><span class="comment"> *     com/mycompany/package1/service-context.xml</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * may be in only one location, but when a path such as</span></span><br><span class="line"><span class="comment"> * &lt;pre class=&quot;code&quot;&gt;</span></span><br><span class="line"><span class="comment"> *     classpath:com/mycompany/**&amp;#47;service-context.xml</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * is used to try to resolve it, the resolver will work off the (first) URL</span></span><br><span class="line"><span class="comment"> * returned by &#123;<span class="doctag">@code</span> getResource(&quot;com/mycompany&quot;);&#125;. If this base package node</span></span><br><span class="line"><span class="comment"> * exists in multiple classloader locations, the actual end resource may not be</span></span><br><span class="line"><span class="comment"> * underneath. Therefore, preferably, use &quot;&#123;<span class="doctag">@code</span> classpath*:&#125;&quot; with the same</span></span><br><span class="line"><span class="comment"> * Ant-style pattern in such a case, which will search &lt;i&gt;all&lt;/i&gt; class path</span></span><br><span class="line"><span class="comment"> * locations that contain the root package.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Colin Sampaleanu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Marius Bogoevici</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Costin Leau</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CLASSPATH_ALL_URL_PREFIX</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.util.AntPathMatcher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.io.ResourceLoader#getResource(String)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ClassLoader#getResources(String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathMatchingResourcePatternResolver</span> <span class="keyword">implements</span> <span class="title class_">ResourcePatternResolver</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 默认采用AntPathMatcher</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">PathMatcher</span> <span class="variable">pathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式匹配，关系图</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823110241.png"></p>
<h3 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h3><h4 id="带着问题"><a href="#带着问题" class="headerlink" title="带着问题"></a>带着问题</h4><p>如何从.class文件中获得注解信息呢？</p>
<p>思考：我们自己实现时是如何获取并解析的？</p>
<ol>
<li>Class.forname(“className”)加载类获得Class对象</li>
<li>反射获取注解？</li>
<li>判断是否存在组件注解，存在为其创建BeanDefinition</li>
<li>看指定了名字没，如没，根据名字生成策略生成一个名字</li>
<li>注册BeanDefinition</li>
</ol>
<h4 id="Spring中的解析过程"><a href="#Spring中的解析过程" class="headerlink" title="Spring中的解析过程"></a>Spring中的解析过程</h4><ol>
<li><p>找源码中读取注解的地方<br>ClassPathScanningCandidateComponentProvider#scanCandidateComponents，重点代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构建扫描包的路径表达式，类似切点表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">            resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">        <span class="comment">// ResourcePatternResolver扫描包获取到.class文件</span></span><br><span class="line">        <span class="comment">// 扫描的逻辑：在包下找.class文件，这里要求能够灵活指定包，就需要用到模式匹配</span></span><br><span class="line">        <span class="comment">// 默认用到的Ant Path模式匹配，如指定的包 com.study.**.service</span></span><br><span class="line">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">traceEnabled</span> <span class="operator">=</span> logger.isTraceEnabled();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Scanning &quot;</span> + resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// MetadataReader，元数据读取器，类似xml读取器？</span></span><br><span class="line">                    <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">                    <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                        <span class="comment">// 最终通过MetadataReader用ScannedGenericBeanDefinition装载了注解bean定义</span></span><br><span class="line">                        <span class="type">ScannedGenericBeanDefinition</span> <span class="variable">sbd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">                        sbd.setSource(resource);</span><br><span class="line">                        <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Identified candidate component class: &quot;</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                            candidates.add(sbd);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                            logger.trace(<span class="string">&quot;Ignored because not matching any filter: &quot;</span> + resource);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                        <span class="string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                    logger.trace(<span class="string">&quot;Ignored because not readable: &quot;</span> + resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="ScannedGenericBeanDefinition"><a href="#ScannedGenericBeanDefinition" class="headerlink" title="ScannedGenericBeanDefinition"></a>ScannedGenericBeanDefinition</h4><p>ScannedGenericBeanDefinition类的内部实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extension of the &#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.GenericBeanDefinition&#125;</span></span><br><span class="line"><span class="comment"> * class, based on an ASM ClassReader, with support for annotation metadata exposed</span></span><br><span class="line"><span class="comment"> * through the &#123;<span class="doctag">@link</span> AnnotatedBeanDefinition&#125; interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 继承自GenericBeanDefinition类，基于ASM ClassReader的AnnotatedBeanDefinition实现，支持注解元数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class does &lt;i&gt;not&lt;/i&gt; load the bean &#123;<span class="doctag">@code</span> Class&#125; early.</span></span><br><span class="line"><span class="comment"> * It rather retrieves all relevant metadata from the &quot;.class&quot; file itself,</span></span><br><span class="line"><span class="comment"> * parsed with the ASM ClassReader. It is functionally equivalent to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AnnotatedGenericBeanDefinition#AnnotatedGenericBeanDefinition(AnnotationMetadata)&#125;</span></span><br><span class="line"><span class="comment"> * but distinguishes by type beans that have been &lt;em&gt;scanned&lt;/em&gt; vs those that have</span></span><br><span class="line"><span class="comment"> * been otherwise registered or detected by other means.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getMetadata()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanClassName()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.type.classreading.MetadataReaderFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AnnotatedGenericBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannedGenericBeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">GenericBeanDefinition</span> <span class="keyword">implements</span> <span class="title class_">AnnotatedBeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata metadata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new ScannedGenericBeanDefinition for the class that the</span></span><br><span class="line"><span class="comment">	 * given MetadataReader describes.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> metadataReader the MetadataReader for the scanned target class</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ScannedGenericBeanDefinition</span><span class="params">(MetadataReader metadataReader)</span> &#123;</span><br><span class="line">		Assert.notNull(metadataReader, <span class="string">&quot;MetadataReader must not be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">		setBeanClassName(<span class="built_in">this</span>.metadata.getClassName());</span><br><span class="line">		setResource(metadataReader.getResource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> AnnotationMetadata <span class="title function_">getMetadata</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.metadata;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> MethodMetadata <span class="title function_">getFactoryMethodMetadata</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回看BeanDefinition的继承体系结构</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210820101354.png"></p>
<p>ScannedGenericBeanDefinition是AnnotatedBeanDefinition接口的实现类</p>
<p><strong>注解Bean定义的疑问</strong></p>
<ol>
<li>为什么2.5要增加AnnotatedBeanDefinition？用GenericBeanDefinition不可以吗？</li>
<li>是不是注解方式的Bean定义信息的存放及使用方式与通用Bean定义方式不一样了？</li>
</ol>
<p>上面问题的答案我们只能从创建bean定义和实例化bean时的源码中找答案了。</p>
<ul>
<li><p>首先来搞清楚AnnotatedBeanDefinition接口中增加的两个get。</p>
<ul>
<li><p>这两个get获取的是谁上的信息？</p>
<p>被注解的类上的。</p>
</li>
<li><p>那就搞的清楚两个get返回的是什么了：</p>
<ul>
<li>AnnotationMetadata : 类上的注解的元信息</li>
<li>getFactoryMethodMetadata(): MethodMetadata : 如果是工厂方法方式，获取工厂方法元信息。这个方法是4.1.1才开始有的。在context.jar的范围未看到有使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以看出来AnnotatedBeanDefinition是在Spring2.5才加入的，getFactoryMethodMetadata方法是4.1.1才加入的。这些都是后期新增特性才提供的。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823130243.png"></p>
<p><strong>元数据信息</strong></p>
<ul>
<li><p>疑问：AnnotationMetadata、MethodMetaData、ClassMetadata所谓的元信息是什么？</p>
<p>Spring中定义的一套方案来描述一个类、一个类上的注解、一个方法等的描述接口，里面定义一些相关的操作。</p>
<p>比如：</p>
<ul>
<li>类：类的名称是什么，它有什么修饰符等</li>
<li>注解：类上的注解的名字，注解的元注解信息有什么、注解的注释信息是什么，注解里面有哪些属性等。</li>
</ul>
<p>在org.springframework.core.type包下定义了相关的接口，可以进行了解</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823130954.png"></p>
</li>
</ul>
<h4 id="MetadataReader"><a href="#MetadataReader" class="headerlink" title="MetadataReader"></a>MetadataReader</h4><p>MetadataReader接口定义如下，通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple facade for accessing class metadata,</span></span><br><span class="line"><span class="comment"> * as read by an ASM &#123;<span class="doctag">@link</span> org.springframework.asm.ClassReader&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过ASM的ClassReader读取类的元信息，提供一个简单的外观模式。</span></span><br><span class="line"><span class="comment"> * 1. 用ASM来实现这个功能；2. 这是一个简单的外观模式实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MetadataReader</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the resource reference for the class file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Resource <span class="title function_">getResource</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Read basic class metadata for the underlying class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ClassMetadata <span class="title function_">getClassMetadata</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Read full annotation metadata for the underlying class,</span></span><br><span class="line"><span class="comment">	 * including metadata for annotated methods.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	AnnotationMetadata <span class="title function_">getAnnotationMetadata</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> MetadataReader&#125; implementation based on an ASM</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.asm.ClassReader&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Costin Leau</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SimpleMetadataReader</span> <span class="keyword">implements</span> <span class="title class_">MetadataReader</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PARSING_OPTIONS</span> <span class="operator">=</span> ClassReader.SKIP_DEBUG</span><br><span class="line">			| ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Resource resource;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata annotationMetadata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	SimpleMetadataReader(Resource resource, <span class="meta">@Nullable</span> ClassLoader classLoader) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 构建注解元数据读取访问者</span></span><br><span class="line">		<span class="type">SimpleAnnotationMetadataReadingVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAnnotationMetadataReadingVisitor</span>(classLoader);</span><br><span class="line">        <span class="comment">// 创建资源对应的ASM ClassReader对象，并且对用visitor对ClassReader对象进行访问解读</span></span><br><span class="line">		getClassReader(resource).accept(visitor, PARSING_OPTIONS);</span><br><span class="line">        <span class="comment">// 扫描到的带有注解的类</span></span><br><span class="line">		<span class="built_in">this</span>.resource = resource;</span><br><span class="line">        <span class="comment">// 获得注解元数据信息</span></span><br><span class="line">		<span class="built_in">this</span>.annotationMetadata = visitor.getMetadata();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ClassReader <span class="title function_">getClassReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> resource.getInputStream()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(is);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;ASM ClassReader failed to parse class file - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;probably due to a new Java class file version that isn&#x27;t supported yet: &quot;</span> + resource, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Resource <span class="title function_">getResource</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.resource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ClassMetadata <span class="title function_">getClassMetadata</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.annotationMetadata;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> AnnotationMetadata <span class="title function_">getAnnotationMetadata</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.annotationMetadata;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ASM是什么？</strong></p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://asm.ow2.io/">https://asm.ow2.io/</a></p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823131653.png"></p>
<p>总结：Spring中通过ASM字节码操作库来读取的类信息、注解信息，又学到了一种方式来获取类中的信息，它们的类关系图如下。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823131838.png"></p>
<p>提问：spring中通过ASM字节码操作库来读取的类信息、注解信息。它没有加载类，为什么不用加载类的方式？</p>
<ol>
<li>反射是读取持久堆上存储的类信息。而 ASM 是直接处理 .class 字节码。性能比反射快。</li>
<li>反射读取类信息时需要进行类加载处理，而 ASM 则不需要将类加载到内存中。内存占用比反射低。</li>
<li>反射只能读取类信息，而 ASM 除了读还能写。</li>
</ol>
<p>反射相对于 ASM 来说使用方便，想直接操纵 ASM 的话需要有 JVM 指令基础。</p>
<h4 id="MetadataReader与ScannedGenericBeanDefinition"><a href="#MetadataReader与ScannedGenericBeanDefinition" class="headerlink" title="MetadataReader与ScannedGenericBeanDefinition"></a>MetadataReader与ScannedGenericBeanDefinition</h4><p>MetadataReader读取到类信息、注解信息后，如何进行判断及创建BeanDefinition的，往BeanDefintion中给入了哪些信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">            resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">traceEnabled</span> <span class="operator">=</span> logger.isTraceEnabled();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Scanning &quot;</span> + resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// MetadataReader，元数据读取器，类似xml读取器？</span></span><br><span class="line">                    <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">                    <span class="comment">// 1. 判断是否是候选组件？进入方法看看</span></span><br><span class="line">                    <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                        <span class="comment">// 2. MetadataReader给ScannedGenericBeanDefinition装载什么信息？</span></span><br><span class="line">                        <span class="type">ScannedGenericBeanDefinition</span> <span class="variable">sbd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">                        sbd.setSource(resource);</span><br><span class="line">                        <span class="comment">// 3. 必须是一个可以继承的类，不能是接口和封闭类，抽象类必须有Lookup注解</span></span><br><span class="line">                        <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Identified candidate component class: &quot;</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                            candidates.add(sbd);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123; <span class="comment">// 忽略，不是一个顶层的具体类</span></span><br><span class="line">                            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                logger.debug(<span class="string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// 忽略，不能匹配到过滤器</span></span><br><span class="line">                        <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                            logger.trace(<span class="string">&quot;Ignored because not matching any filter: &quot;</span> + resource);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                        <span class="string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                    logger.trace(<span class="string">&quot;Ignored because not readable: &quot;</span> + resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扫描过滤器</strong></p>
<ol>
<li>过滤匹配处要搞清楚的内容：<ol>
<li>Filter从何而来，默认情况下有什么filter？</li>
<li>匹配的过程是怎样的？</li>
<li>@service @controller等是怎么匹配到的？</li>
</ol>
</li>
</ol>
<p>ClassPathScanningCandidateComponentProvider#isCandidateComponent(MetadataReader) 488</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeFilter tf : <span class="built_in">this</span>.excludeFilters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (TypeFilter tf : <span class="built_in">this</span>.includeFilters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">            <span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Filter从何而来，默认情况下有什么filter？</p>
<p>ClassPathScanningCandidateComponentProvider#registerDefaultFilters 205</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerDefaultFilters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Component.class));</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(</span><br><span class="line">            ((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;) ClassUtils.forName(<span class="string">&quot;javax.annotation.ManagedBean&quot;</span>, cl)), <span class="literal">false</span>));</span><br><span class="line">        logger.trace(<span class="string">&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(</span><br><span class="line">            ((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;) ClassUtils.forName(<span class="string">&quot;javax.inject.Named&quot;</span>, cl)), <span class="literal">false</span>));</span><br><span class="line">        logger.trace(<span class="string">&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnnotationTypeFilter的父类AbstractTypeHierarchyTraversingFilter#match(MetadataReader,MetadataReaderFactory)方法</p>
<p>最后会到AnnotationTypeFilter#matchSelf方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">matchSelf</span><span class="params">(MetadataReader metadataReader)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line">    <span class="comment">// 包含指定的注解 或者 注解里面包含指定注解， 比如指定的@Componet注解，在@Service注解中有包含</span></span><br><span class="line">    <span class="keyword">return</span> metadata.hasAnnotation(<span class="built_in">this</span>.annotationType.getName()) ||</span><br><span class="line">        (<span class="built_in">this</span>.considerMetaAnnotations &amp;&amp; metadata.hasMetaAnnotation(<span class="built_in">this</span>.annotationType.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Configuration、@Controller、@Service、@Repository注解中类似@Service，都包含@Component注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 包含Component注解，类似继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">	 * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考</strong></p>
<ul>
<li><p>我们可以自己定义标注组件的注解吗？【扩展点】</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-meta-annotations">https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-meta-annotations</a></p>
</li>
<li><p>扫描的过滤这块你在实际项目中是否用过？如何使用的？【扩展点】</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-scanning-filters">https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/core.html#beans-scanning-filters</a></p>
<p>TypeFilter的实现类<br><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210823133942.png"></p>
<p>自定义实现TypeFilter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title class_">TypeFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用metadataReader中的类信息、注解信息来进行你的过滤判断逻辑</span></span><br><span class="line">        <span class="keyword">return</span> metadataReader.getClassMetadata().getClassName().equals(GarfieldCat.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Controller注解，它和@Service、@Component注解有不同的意图，这种不同的意图将会在哪里实现？如果我们自己也有类似的需求自定义组件注解，是不就可以模仿@Controller。猜想spring是如何实现灵活扩展的？</p>
</li>
<li><p>为何ScannedGrenericBeanDefinition没有提取依赖注入相关的信息？这些为什么现在不提取？会在什么时候提取？<br>ClassPathBeanDefinitionScanner#scan(String[])</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            <span class="comment">// 设置bean的作用域</span></span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// 设置bean的默认配置以及是否作为候选bean配置</span></span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// 设置bean的LazyInit、Primary、DependsOn、Role、Description配置</span></span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">                <span class="comment">// 为所提供的目标bean生成作用域代理，使用内部名称注册目标bean并在作用域代理上设置“targetBeanName”。</span></span><br><span class="line">                definitionHolder =</span><br><span class="line">                    AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Bean定义的注册逻辑"><a href="#Bean定义的注册逻辑" class="headerlink" title="Bean定义的注册逻辑"></a>Bean定义的注册逻辑</h2><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p>BeanDefinitionReaderUtils#registerBeanDefinition方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    <span class="comment">// 通过bean工厂注册bean定义</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    <span class="comment">// 给beanName和别名绑定</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><p>DefaultListableBeanFactory#registerBeanDefinition方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 如果有继承自AbstractBeanDefinition，则先对Bean定义进行校验</span></span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                                                   <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 是否已经存在相关Bean定义，先进行判断</span></span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123; <span class="comment">// 2.1 beanName的Bean定义已经存在的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123; <span class="comment">// 2.1.1 不允许重写覆盖，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125; <span class="comment">// 2.1.2 允许重写覆盖的处理，进行一些日志信息的打印，告知处理的信息</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                            <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                            existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                             <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                             <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.1.3 覆盖原有的Bean定义</span></span><br><span class="line">        <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.2 beanName的Bean定义不存在的情况处理</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.2.1 当前Bean对象是否正在创建</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="comment">// 2.2.1.1 启动期间，同步处理，防止其他地方集合的迭代异常</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="comment">// 使用ConcurrentHashMap进行存储</span></span><br><span class="line">                <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 2.2.2 当前bean还没有开始创建，直接put</span></span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 如果对应的单例bean存在，则重置这个Bean</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要冻结配置，清除类型映射缓存</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="别名处理"><a href="#别名处理" class="headerlink" title="别名处理"></a>别名处理</h3><p>将别名作为Key，beanName作为Value进行map存储，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerAlias</span><span class="params">(String name, String alias)</span> &#123;</span><br><span class="line">    Assert.hasText(name, <span class="string">&quot;&#x27;name&#x27; must not be empty&quot;</span>);</span><br><span class="line">    Assert.hasText(alias, <span class="string">&quot;&#x27;alias&#x27; must not be empty&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.aliasMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.aliasMap.remove(alias);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Alias definition &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; ignored since it points to same name&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">registeredName</span> <span class="operator">=</span> <span class="built_in">this</span>.aliasMap.get(alias);</span><br><span class="line">            <span class="keyword">if</span> (registeredName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">                    <span class="comment">// An existing alias - no need to re-register</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot define alias &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; for name &#x27;&quot;</span> +</span><br><span class="line">                                                    name + <span class="string">&quot;&#x27;: It is already registered for name &#x27;&quot;</span> + registeredName + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Overriding alias &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; definition for registered name &#x27;&quot;</span> +</span><br><span class="line">                                 registeredName + <span class="string">&quot;&#x27; with new target name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            checkForAliasCircle(name, alias);</span><br><span class="line">            <span class="built_in">this</span>.aliasMap.put(alias, name);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Alias definition &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; registered for name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


















      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/02-Spring/06-Spring%E6%BA%90%E7%A0%81-Bean%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" data-id="clmcxecsy006yu8wa9hcv34j4" data-title="Spring源码-Bean定义加载过程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/07/02-Spring/05-Spring%E6%BA%90%E7%A0%81-IOC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Spring源码-IOC容器初始化过程
        
      </div>
    </a>
  
  
    <a href="/2021/05/07/02-Spring/07-Spring%E6%BA%90%E7%A0%81-IOC%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Spring源码-IOC容器核心流程</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ActiveMQ/">ActiveMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dubbo/">Dubbo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/K8s/">K8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kafka/">Kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RabbitMQ/">RabbitMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Socker/">Socker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Zookeeper/">Zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActiveMQ/" rel="tag">ActiveMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CDH/" rel="tag">CDH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/" rel="tag">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/" rel="tag">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KDTree/" rel="tag">KDTree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/" rel="tag">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/" rel="tag">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socker/" rel="tag">Socker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/" rel="tag">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YARN/" rel="tag">YARN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZooKeeper/" rel="tag">ZooKeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag">注解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" rel="tag">集合源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ActiveMQ/" style="font-size: 10px;">ActiveMQ</a> <a href="/tags/CDH/" style="font-size: 10px;">CDH</a> <a href="/tags/Docker/" style="font-size: 18px;">Docker</a> <a href="/tags/Dubbo/" style="font-size: 13px;">Dubbo</a> <a href="/tags/Golang/" style="font-size: 19px;">Golang</a> <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/K8s/" style="font-size: 10px;">K8s</a> <a href="/tags/KDTree/" style="font-size: 10px;">KDTree</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/MQ/" style="font-size: 10px;">MQ</a> <a href="/tags/MapReduce/" style="font-size: 10px;">MapReduce</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 14px;">Mybatis</a> <a href="/tags/Netty/" style="font-size: 14px;">Netty</a> <a href="/tags/RPC/" style="font-size: 11px;">RPC</a> <a href="/tags/RabbitMQ/" style="font-size: 15px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 17px;">Redis</a> <a href="/tags/Socker/" style="font-size: 10px;">Socker</a> <a href="/tags/Spark/" style="font-size: 11px;">Spark</a> <a href="/tags/Spring/" style="font-size: 20px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/Tomcat/" style="font-size: 13px;">Tomcat</a> <a href="/tags/YARN/" style="font-size: 11px;">YARN</a> <a href="/tags/ZooKeeper/" style="font-size: 12px;">ZooKeeper</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 16px;">多线程</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 10px;">注解</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 11px;">设计模式</a> <a href="/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" style="font-size: 13px;">集合源码</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/05-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/04-Sharding-JDBC%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/03-MyCat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/02-MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/01-MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>