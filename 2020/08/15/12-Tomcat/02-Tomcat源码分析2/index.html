<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Tomcat源码分析2 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Tomcat中的组件BootstrapTomcat的启动类，最终交给Catalina对象初始化Tomcat，它所完成的工作。  初始化类加载器 初始化Catalina，通过反射进行调用 处理启动参数命令  ClassLoaderJVM类加载器及双亲委派JVM类加载器结构 示例代码 1234567891011121314public class Main &amp;#123;    public stati">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat源码分析2">
<meta property="og:url" content="http://example.com/2020/08/15/12-Tomcat/02-Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Tomcat中的组件BootstrapTomcat的启动类，最终交给Catalina对象初始化Tomcat，它所完成的工作。  初始化类加载器 初始化Catalina，通过反射进行调用 处理启动参数命令  ClassLoaderJVM类加载器及双亲委派JVM类加载器结构 示例代码 1234567891011121314public class Main &amp;#123;    public stati">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926091359.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926093532.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926102219.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926103944.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926111352.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926111708.png">
<meta property="og:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926123124.png">
<meta property="article:published_time" content="2020-08-15T08:50:45.000Z">
<meta property="article:modified_time" content="2021-12-12T10:56:14.297Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Tomcat">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926091359.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-12-Tomcat/02-Tomcat源码分析2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/15/12-Tomcat/02-Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/" class="article-date">
  <time class="dt-published" datetime="2020-08-15T08:50:45.000Z" itemprop="datePublished">2020-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tomcat/">Tomcat</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Tomcat源码分析2
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Tomcat中的组件"><a href="#Tomcat中的组件" class="headerlink" title="Tomcat中的组件"></a>Tomcat中的组件</h1><h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>Tomcat的启动类，最终交给Catalina对象初始化Tomcat，它所完成的工作。</p>
<ul>
<li>初始化类加载器</li>
<li>初始化Catalina，通过反射进行调用</li>
<li>处理启动参数命令</li>
</ul>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><h3 id="JVM类加载器及双亲委派"><a href="#JVM类加载器及双亲委派" class="headerlink" title="JVM类加载器及双亲委派"></a>JVM类加载器及双亲委派</h3><h4 id="JVM类加载器结构"><a href="#JVM类加载器结构" class="headerlink" title="JVM类加载器结构"></a>JVM类加载器结构</h4><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926091359.png"></p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        System.out.println(main.getClass().getClassLoader());</span><br><span class="line">        System.out.println(main.getClass().getClassLoader().getParent());</span><br><span class="line">        System.out.println(main.getClass().getClassLoader().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@372f7a8d</span><br><span class="line"><span class="literal">null</span> <span class="comment">// 由于启动类加载器是 C/C++ 语言写的，所以输出为 null</span></span><br></pre></td></tr></table></figure>

<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><ul>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<p>每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。</p>
<h4 id="双亲委派优势"><a href="#双亲委派优势" class="headerlink" title="双亲委派优势"></a>双亲委派优势</h4><ul>
<li><p>避免重复加载</p>
<p>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，子ClassLoader就没有必要再加载一次。</p>
</li>
<li><p>安全-防止核心API库被篡改</p>
<p>java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang; <span class="comment">// 自定义的包,伪装成java.lang.String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是自定义的java.lang.String类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 jre\lib\ext 中存在 java.lang.String 类，当加载该类的时候，根据全限定名进行查找，找到后由启动类加载器加载，发现 String 类中不包含 main() 方法，因此程序出错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Tomcat的类加载器"><a href="#Tomcat的类加载器" class="headerlink" title="Tomcat的类加载器"></a>Tomcat的类加载器</h3><p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926093532.png"></p>
<p>Catalina类加载器和Shared类加载器，他们并不是父子关系，而是兄弟关系。为啥这样设计？</p>
<ol>
<li>保证应用程序各自类库的独立隔离，一个Web容器可能需要部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</li>
<li>共享相同版本类库，部署在同一个Web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，显然不合适。</li>
<li>安全-隔离Web容器与应用程序类库，Web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li>
<li>支持JSP热修改，Web容器要支持jsp的修改，jsp文件最终编译成class文件才能在虚拟机中运行，在程序运行后修改jsp是常见的事，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。</li>
</ol>
<h4 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h4><p>WebAppClassLoader与JasperLoader查找类则不会先往上查找，而是直接在自己类加载器中进行查找，不遵循双亲委派机制。</p>
<h4 id="为什么不遵循双亲委派机制？"><a href="#为什么不遵循双亲委派机制？" class="headerlink" title="为什么不遵循双亲委派机制？"></a>为什么不遵循双亲委派机制？</h4><ol>
<li><p>如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。tomcat 为了实现隔离性，没有遵守双亲委派机制. </p>
</li>
<li><p>每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。</p>
</li>
<li><p>每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。双亲委派机制无法做到。</p>
</li>
</ol>
<p>所以双亲委派机制不能满足Tomcat的需求。</p>
<p><strong>如果Tomcat 的 CommonClassLoader 想加载 WebAppClassLoader 中的类，该怎么办？</strong></p>
<p>可以使用线程上下文类加载器实现，使用线程上下文加载器，让父类加载器请求子类加载器去完成类加载的动作。</p>
<h2 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h2><p><code>Catalina</code> 是Tomcat的核心组件，是Servlet容器，Catalina包含了所有的容器组件，其他模块均为Catalina提供支撑。通过Coyote模块提供连接通信，Jasper模块提供JSP引擎，Naming提供JNDI服务，Juli提供日志服务。结构如下：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926102219.png"></p>
<p>主要的功能包括接收请求，处理请求，返回结果，这些具体的实现是在catalina里面的子容器里面。</p>
<h3 id="Catalina类结构"><a href="#Catalina类结构" class="headerlink" title="Catalina类结构"></a>Catalina类结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.startup.Catalina </span></span><br><span class="line"><span class="comment">// 用于await的flag </span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">await</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"><span class="comment">// Server配置的文件路，Server.xml配置文件的地址 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">String</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="string">&quot;conf/server.xml&quot;</span>; </span><br><span class="line"><span class="comment">// 此server的shared 类加载器，父类加载器 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">ClassLoader</span> <span class="variable">parentClassLoader</span> <span class="operator">=</span> Catalina.class.getClassLoader();</span><br><span class="line"><span class="comment">// Server组件，通过digster工具解析server.xml文件构造该对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// 使用shutdown钩子的flag </span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">useShutdownHook</span> <span class="operator">=</span> <span class="literal">true</span>; </span><br><span class="line"><span class="comment">// Shutdown钩子实例，用户shutdown时的钩子 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">Thread</span> <span class="variable">shutdownHook</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// 默认需要开启Naming，是否需要启动JNDI的标识 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">useNaming</span> <span class="operator">=</span> <span class="literal">true</span>; </span><br><span class="line"><span class="comment">// 预防重复加载的标记字段 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">loaded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>Catalina执行的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载server.xml文件，并启动Server </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(String args[])</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Server的start()方法，注册shutdown的钩子到JVM </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭catalina中的server </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Catalina-components"><a href="#Catalina-components" class="headerlink" title="Catalina components"></a>Catalina components</h3><p>Catalina中的核心组件有：Server、Service、Executor、Container（Context、Engine、Host、Wrapper能够处理请求进行响应的组件）等。</p>
<h2 id="Digester"><a href="#Digester" class="headerlink" title="Digester"></a>Digester</h2><h3 id="Digester架构"><a href="#Digester架构" class="headerlink" title="Digester架构"></a>Digester架构</h3><p>Digester采用SAX时间机制解析xml文件，Digester整体架构如下。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926103944.png"></p>
<ul>
<li>最上面的 <code>DefaultHandler</code> 来自SAX， <code>Digester</code> 集成该类，足以说明 <code>Digester</code> 底层用的是SAX了。</li>
<li><code>Client</code> 表示调用Digester的Java代码，比如我们这里的Catalina。 </li>
<li><code>Digester</code> 是Digester组件的核心类和入口类，Client需要实例化该类，设置改类，并调用里面的参数。</li>
<li><code>Rules</code> 是一个保存XML的节点和规则的映射关系的接口，默认实现类是 <code>RulesBase</code></li>
<li><code>RuesBase</code> 是 <code>Rules</code> 的默认实现类。当有一个XML节点开始解析时，会在这里面找是否有对应的节点，并根据节点查找对应的处理规则。</li>
<li><code>Rule</code> 对节点的处理方法的接口，内置的或者自定义的规则都是集成该接口。</li>
<li><code>Rule</code> 是接口 <code>Rule</code> 的很多实现，根据具体的实现不同而不同。因为XML里面的内容是变化的，根据自己的XML内容进行实现。</li>
</ul>
<h4 id="使用Digester解析XML文档的流程："><a href="#使用Digester解析XML文档的流程：" class="headerlink" title="使用Digester解析XML文档的流程："></a>使用Digester解析XML文档的流程：</h4><ol>
<li>首先，Client需要创建一个Digester对象。</li>
<li>然后，Client必须根据自己的XML格式来添加所有的Rule。 </li>
<li>添加完Rule后，Client调用Digester的parse操作来解析XML文件。</li>
<li>Digester实现了SAX的接口，解析时遇到具体的XML对象时会调用startElement等接口函数。</li>
<li>在这些SAX接口函数中，会扫描规则链(RulesBase)，找到匹配规则，规则匹配一般都是根据具体的元素名称来进行匹配。</li>
<li>找到对应的rule后，依次执行rule，这里的startElement对应的是begin操作，endElement对应的是end操作，具体要做的事情都在每个rule的begin，body，end函数中。</li>
<li>文档结束后，会执行所有rule的finish函数。</li>
</ol>
<h3 id="解析server-xml文件"><a href="#解析server-xml文件" class="headerlink" title="解析server.xml文件"></a>解析server.xml文件</h3><p>Digester用栈来维护每个<strong>正在解析的</strong>对象，开始解析时就放入栈，解析完就弹出栈。</p>
<p>Catalina的使用步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.用digester解析server.xml文件，把配置文件中的配置解析成java对象 </span></span><br><span class="line"><span class="comment">//3.1.准备好用来解析server.xml文件需要用的digester。 </span></span><br><span class="line"><span class="type">Digester</span> <span class="variable">digester</span> <span class="operator">=</span> createStartDigester(); </span><br><span class="line"><span class="comment">//3.2.server.xml文件作为一个输入流传入 </span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> configFile(); </span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file); </span><br><span class="line"><span class="comment">//3.3.使用inputStream构造一个sax的inputSource </span></span><br><span class="line"><span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(file.toURI().toURL().toString());</span><br><span class="line">inputSource.setByteStream(inputStream); </span><br><span class="line"><span class="comment">//3.4.把当前类压入到digester的栈顶，用来作为digester解析出来的对象的一种引用 </span></span><br><span class="line">digester.push(<span class="built_in">this</span>); </span><br><span class="line"><span class="comment">//3.5.调用digester的parse()方法进行解析。 </span></span><br><span class="line">digester.parse(inputSource);</span><br></pre></td></tr></table></figure>

<p>创建Digester方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个digester实例 </span></span><br><span class="line"><span class="type">Digester</span> <span class="variable">digester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digester</span>(); </span><br><span class="line"><span class="comment">//是否对xml文档进行类似XSD等类型的校验，默认为fasle。 </span></span><br><span class="line">digester.setValidating(<span class="literal">false</span>); </span><br><span class="line"><span class="comment">//是否进行节点设置规则校验，如果xml中相应节点没有设置解析规则会在控制台显示提示信息。 </span></span><br><span class="line">digester.setRulesValidation(<span class="literal">true</span>); </span><br><span class="line"><span class="comment">//将XML节点中的className作为假属性，不必调用默认的setter方法 </span></span><br><span class="line"><span class="comment">//(一般的节点属性在解析时会以属性作为入参调用该节点相应对象的setter方法，而className属性的用</span></span><br><span class="line"><span class="comment">// 提示解析器使用该属性的值作来实例化对象) </span></span><br><span class="line">Map&lt;Class&lt;?&gt;, List&lt;String&gt;&gt; fakeAttributes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">List&lt;String&gt; objectAttrs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">objectAttrs.add(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">fakeAttributes.put(Object.class, objectAttrs); </span><br><span class="line"><span class="comment">// Ignore attribute added by Eclipse for its internal tracking </span></span><br><span class="line">List&lt;String&gt; contextAttrs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">contextAttrs.add(<span class="string">&quot;source&quot;</span>); </span><br><span class="line">fakeAttributes.put(StandardContext.class, contextAttrs); </span><br><span class="line">digester.setFakeAttributes(fakeAttributes); </span><br><span class="line"><span class="comment">//使用当前线程的上下文类加载器，主要加载FactoryCreateRule和ObjectCreateRule</span></span><br><span class="line">digester.setUseContextClassLoader(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>创建Server实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数指定操作的xml节点，这里值server节点，server对象最终由Catalina装配 </span></span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;Server&quot;</span>,<span class="string">&quot;org.apache.catalina.core.StandardServer&quot;</span>,<span class="string">&quot;className&quot;</span>); </span><br><span class="line">digester.addSetProperties(<span class="string">&quot;Server&quot;</span>); </span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server&quot;</span>,<span class="string">&quot;setServer&quot;</span>,<span class="string">&quot;org.apache.catalina.Server&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>创建对象，设置属性，调用方法添加到Catalina类中。</p>
<p>其他的组件添加都类似，Service、Lifecycle、Host、Executor、Connector等等。</p>
<h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Tomcat的卡特琳娜（Catalina）由许多组件构成。当Catalina启动的时候，这些组件也要跟着一起启动，并且当Catalina关闭的时候，这些组件也要同时关闭，并且要进行必要的清理操作，释放资源。例如，当容器关闭的时候，需要调用已加载的servlet对象的destroy方法，session对象也要持久化到secondary storage（二级存储，通常指的就是硬盘）。这就要求所有Component有一致的方法，可以统一处理。</p>
<p>整体采用了观察者设计模式。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926111352.png"></p>
<p>Lifecycle接口实现体系：</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926111708.png"></p>
<p>子接口包含了Server、Service、Container等各组件，可见基本所有核心组件都实现了Lifecycle接口。</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>Server组件用于描述一个启动的Tomcat实例，一个Tocmat被启动，在操作系统中占用一个进程号，提供web服务的功能，那个这个整个服务用Server来表示。</p>
<h3 id="StandardServer结构"><a href="#StandardServer结构" class="headerlink" title="StandardServer结构"></a>StandardServer结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StandardServer</span>&#123; </span><br><span class="line">    <span class="comment">//1.java命令和地址服务相 </span></span><br><span class="line">    <span class="comment">// JNDI的context </span></span><br><span class="line">    <span class="keyword">private</span> javax.naming.<span class="type">Context</span> <span class="variable">globalNamingContext</span> <span class="operator">=</span> <span class="literal">null</span> </span><br><span class="line">	<span class="comment">// JNDI的resource </span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">NamingResourcesImpl</span> <span class="variable">globalNamingResources</span> <span class="operator">=</span> <span class="literal">null</span> </span><br><span class="line">	<span class="comment">// 作用与web application的JDNI监听器 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> NamingContextListener namingContextListener; </span><br><span class="line">	<span class="comment">//2.shutdown服务相关 </span></span><br><span class="line">	<span class="comment">// 用于等待shutdown命令的端口号 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8905</span> </span><br><span class="line">	<span class="comment">// 用于等待shutdown命令的地址 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>; </span><br><span class="line">	<span class="comment">// shutdown服务在等待的命令 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">shutdown</span> <span class="operator">=</span> <span class="string">&quot;SHUTDOWN&quot;</span>; </span><br><span class="line">	<span class="comment">// 执行await()的线程</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">Thread</span> <span class="variable">awaitThread</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// 用于等待shutdown的socket对象 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ServerSocket</span> <span class="variable">awaitSocket</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">	<span class="comment">// stopAwait的标记位 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stopAwait</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">	<span class="comment">//3.子组件Service相关 </span></span><br><span class="line">	<span class="comment">// Server下的service集合 </span></span><br><span class="line">	<span class="keyword">private</span> Service services[] = <span class="keyword">new</span> <span class="title class_">Service</span>[<span class="number">0</span>] </span><br><span class="line">	<span class="comment">// Service用到的锁 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">servicesLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">	<span class="comment">//4.父类加载器 </span></span><br><span class="line">    <span class="comment">//父类加载器 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ClassLoader</span> <span class="variable">parentClassLoader</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//5.catalina相关的 </span></span><br><span class="line">    <span class="comment">//catalinaHome的地址 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">File</span> <span class="variable">catalinaHome</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//catalinaBase的地址 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">File</span> <span class="variable">catalinaBase</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StandardServer方法"><a href="#StandardServer方法" class="headerlink" title="StandardServer方法"></a>StandardServer方法</h3><p>启动Server需要调用两个方法，在真正的start()方法之前还需要执行init()方法，init方法是一个pre-start()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化动作 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException; </span><br><span class="line"><span class="comment">// 启动方法 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException; </span><br><span class="line"><span class="comment">// 关闭处理 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">stopInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException;</span><br></pre></td></tr></table></figure>

<p>关闭流程是怎样的？</p>
<p>Tomcat的main线程在启动完所有的组件后，自己开一个socket服务端，在指定的端口（默认8005）上进行监听，一直到有shutdown命令发送过来，就退出socket的等待，开始执行关闭方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.catalina.startup.Catalina#start </span></span><br><span class="line"><span class="comment">// 等待处理及停止 </span></span><br><span class="line"><span class="keyword">if</span> (await) &#123; </span><br><span class="line">    await(); </span><br><span class="line">    stop(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await方法中则是Server类中的等待关闭命令的socket实现。stop方法则是Catalina中进行生命周期状态控制，以及Server类的关闭及销毁方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.catalina.startup.Catalina#stop </span></span><br><span class="line"><span class="comment">// Shut down the server </span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="type">Server</span> <span class="variable">s</span> <span class="operator">=</span> getServer(); </span><br><span class="line">    <span class="type">LifecycleState</span> <span class="variable">state</span> <span class="operator">=</span> s.getState();</span><br><span class="line">    <span class="keyword">if</span> (LifecycleState.STOPPING_PREP.compareTo(state) &lt;= <span class="number">0</span> &amp;&amp; LifecycleState.DESTROYED.compareTo(state) &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">	<span class="comment">// Nothing to do. stop() was already called </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="comment">//调用Server的stop方法 </span></span><br><span class="line">    s.stop(); </span><br><span class="line">    <span class="comment">//调用Server的destroy方法 </span></span><br><span class="line">    s.destroy(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">catch</span> (LifecycleException e) &#123; </span><br><span class="line">    log.error(<span class="string">&quot;Catalina.stop&quot;</span>, e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server的stop()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">stopInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123; </span><br><span class="line">    <span class="comment">// 1.设置生命周期的状态， </span></span><br><span class="line">    setState(LifecycleState.STOPPING); </span><br><span class="line">    fireLifecycleEvent(CONFIGURE_STOP_EVENT, <span class="literal">null</span>); </span><br><span class="line">    <span class="comment">// 2.调用所有的Service的stop方法 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; services.length; i++) &#123; </span><br><span class="line">        services[i].stop(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.停止JDNI </span></span><br><span class="line">    globalNamingResources.stop(); </span><br><span class="line">    <span class="comment">// 4.清理等待线程和socket </span></span><br><span class="line">    stopAwait(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server的destroy()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">destroyInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123; </span><br><span class="line">    <span class="comment">// 1.调用所有的service的destroy()方法 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; services.length; i++) &#123; </span><br><span class="line">    	services[i].destroy(); </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//2.调用JNDI的destroy() </span></span><br><span class="line">	globalNamingResources.destroy(); </span><br><span class="line">    <span class="comment">//3.解绑MBean,和String Cache，对应init方法中的注册。 </span></span><br><span class="line">    unregister(onameMBeanFactory); </span><br><span class="line">    unregister(onameStringCache); </span><br><span class="line">    <span class="comment">//4.调用父类的方法 </span></span><br><span class="line">    <span class="built_in">super</span>.destroyInternal(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前面的分析Server相关联的组件有：多个Service组件，JDNI组件，JMX组件，类加载器组件</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Tomcat中只有一个Server，一个Server可以用多个Service，Server掌握着整个Tomcat的生死大权，Service是对外提供服务的。</p>
<p>一个Service可以有多个Connector和一个Container。Connector用于接收请求并将请求封装成Request和Response的具体处理。Container用于封装和管理Servlet，以及reqeust请求的具体处理。</p>
<p>一个Service包含多个Connector和一个Engine，两者的关联关系使用Mapper来做映射，还有一个可选的线程池Executor。</p>
<p><img src="https://raw.githubusercontent.com/chengchen901/img/master/blog/20210926123124.png"></p>
<h3 id="Service类结构"><a href="#Service类结构" class="headerlink" title="Service类结构"></a>Service类结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service的名称 </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// Service所属的Server </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// 组件对属性改变的支持 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">PropertyChangeSupport</span> <span class="variable">support</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyChangeSupport</span>(<span class="built_in">this</span>); </span><br><span class="line"><span class="comment">// 跟这个Service相关联的Connector集合 </span></span><br><span class="line"><span class="keyword">protected</span> Connector connectors[] = <span class="keyword">new</span> <span class="title class_">Connector</span>[<span class="number">0</span>]; </span><br><span class="line"><span class="comment">// Connector的锁 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">connectorsLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"><span class="comment">// 线程池 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ArrayList&lt;Executor&gt; executors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// Servlet的引擎 </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Engine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// 类加载器 </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ClassLoader</span> <span class="variable">parentClassLoader</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// Mapper. </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Mapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mapper</span>(); </span><br><span class="line"><span class="comment">// Mapper 监听器 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">MapperListener</span> <span class="variable">mapperListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperListener</span>(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>关键的几个点：</p>
<ul>
<li>Connector connectors[]：多个连接器，一个Servlet服务接受两个不同的协议连接，只不过不同的协议通过对应的Connector都被处理成了一个Request对象，这样对于Engine来说，都是一样的请求。</li>
<li>Engine engine：Servlet引擎，就是专门用来处理请求的，其他的都不管。</li>
<li>Mapper mapper：mapper保存了一个映射关系，不同请求路径对应哪一个Servlet的API。</li>
<li>PropertyChangeSupport support：JDK自带的观察者模式，主要是观察Java Bean对象的属性更改。</li>
</ul>
<p>在Service属性中，主要就是这四个东西，主要的架构关系，在上面的图中有解析，就不再多介绍。</p>
<h3 id="Service方法"><a href="#Service方法" class="headerlink" title="Service方法"></a>Service方法</h3><p>Service的方法比较简单，因为只是包装，自己没有太多的一个功能，所有主要功能有：</p>
<ol>
<li>监听Service属性变化，</li>
<li>启动</li>
<li>关闭。</li>
</ol>
<h4 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h4><p>init方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.父类执行init</span></span><br><span class="line">    <span class="built_in">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.执行servlet的引擎engine的init</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="literal">null</span>) &#123;</span><br><span class="line">        engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.执行Executors的init</span></span><br><span class="line">    <span class="comment">// Initialize any Executors</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">            ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">        &#125;</span><br><span class="line">        executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.mapper监听器的init</span></span><br><span class="line">    <span class="comment">// Initialize mapper listener</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.connect的init</span></span><br><span class="line">    <span class="comment">// Initialize our defined Connectors</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">            connector.init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>start、stop、destroy方法与init方法都差不多的形式</p>
<h4 id="监听Service属性变化"><a href="#监听Service属性变化" class="headerlink" title="监听Service属性变化"></a>监听Service属性变化</h4><p>你怎么去监听一个java对象的属性被改变了？</p>
<p>使用监听器设计模式，是的！但是JDK已经提供好了这种使用方法，并在Tomcat里有了比较好的应用。</p>
<p>Tomcat中使用JDK中的 <code>PropertyChangeSupport</code> 类来实现监听的需求，使用该类需要按照如下要求：</p>
<ol>
<li><p>在Service中构造一个PropertyChangeSupport类，并将这个Java Bean传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.core.StandardService </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 属性改变的监听管理 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">PropertyChangeSupport</span> <span class="variable">support</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyChangeSupport</span>(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要在Service中添加对应的添加监听器方法和删除监听器方法，对应如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a property change listener to this component.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener The listener to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span> &#123;</span><br><span class="line">    support.addPropertyChangeListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove a property change listener from this component.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener The listener to remove</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removePropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span> &#123;</span><br><span class="line">    support.removePropertyChangeListener(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，如果需要实现自己的监听器，只需要实现 <code>void propertyChange(PropertyChangeEvent evt);</code> 方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PropertyChangeListener</span> <span class="keyword">extends</span> <span class="title class_">java</span>.util.EventListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method gets called when a bound property is changed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt A PropertyChangeEvent object describing the event source</span></span><br><span class="line"><span class="comment">     *          and the property that has changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">propertyChange</span><span class="params">(PropertyChangeEvent evt)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以来完成对Service属性的监听了，非常好的方法。</p>
</li>
</ol>
<h2 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h2><p>通过CoyoteAdapter创建对应的Protocol，进行请求处理</p>
<p>关键的几个成员属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关联的父容器service，通过它可以获得Engine进行请求的处理 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// Coyote Protocol处理器类名 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> String protocolHandlerClassName; </span><br><span class="line"><span class="comment">// 被配置protocol的名字 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> String configuredProtocol; </span><br><span class="line"><span class="comment">// coyote协议处理，默认Http11AprProtocol </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ProtocolHandler protocolHandler; </span><br><span class="line"><span class="comment">// Coyote 适配器，不干具体的活转换接口. </span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">Adapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>Adapter连接了Tomcat连接器Connector和容器Container.它的实现类是CoyoteAdapter主要负责的是对请求进行封装,构造Request和Response对象.并将请求转发给Container也就是Servlet容器.</p>
<p>关键方法在service中 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Create objects</span></span><br><span class="line">        request = connector.createRequest();</span><br><span class="line">        request.setCoyoteRequest(req);</span><br><span class="line">        response = connector.createResponse();</span><br><span class="line">        response.setCoyoteResponse(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Link objects</span></span><br><span class="line">        request.setResponse(response);</span><br><span class="line">        response.setRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set as notes</span></span><br><span class="line">        req.setNote(ADAPTER_NOTES, request);</span><br><span class="line">        res.setNote(ADAPTER_NOTES, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set query string encoding</span></span><br><span class="line">        req.getParameters().setQueryStringCharset(connector.getURICharset());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connector.getXpoweredBy()) &#123;</span><br><span class="line">        response.addHeader(<span class="string">&quot;X-Powered-By&quot;</span>, POWERED_BY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">async</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">postParseSuccess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    req.getRequestProcessor().setWorkerThreadName(THREAD_NAME.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Parse and set Catalina and configuration specific</span></span><br><span class="line">        <span class="comment">// request parameters</span></span><br><span class="line">        postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">        <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">            <span class="comment">//check valves if we support async</span></span><br><span class="line">            request.setAsyncSupported(</span><br><span class="line">                connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">            <span class="comment">// 调用容器pipeline进行请求处理，其实是触发到Engine，最终到Context</span></span><br><span class="line">            <span class="comment">// Calling the container</span></span><br><span class="line">            connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">            async = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">ReadListener</span> <span class="variable">readListener</span> <span class="operator">=</span> req.getReadListener();</span><br><span class="line">            <span class="keyword">if</span> (readListener != <span class="literal">null</span> &amp;&amp; request.isFinished()) &#123;</span><br><span class="line">                <span class="comment">// Possible the all data may have been read during service()</span></span><br><span class="line">                <span class="comment">// method so this needs to be checked here</span></span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">oldCL</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oldCL = request.getContext().bind(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (req.sendAllDataReadEvent()) &#123;</span><br><span class="line">                        req.getReadListener().onAllDataRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    request.getContext().unbind(<span class="literal">false</span>, oldCL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">throwable</span> <span class="operator">=</span></span><br><span class="line">                (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If an async request was started, is not going to end once</span></span><br><span class="line">            <span class="comment">// this container thread finishes and an error occurred, trigger</span></span><br><span class="line">            <span class="comment">// the async error process</span></span><br><span class="line">            <span class="keyword">if</span> (!request.isAsyncCompleting() &amp;&amp; throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">                request.getAsyncContextInternal().setErrorState(throwable, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.finishRequest();</span><br><span class="line">            response.finishResponse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">AtomicBoolean</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">        res.action(ActionCode.IS_ERROR, error);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.isAsyncCompleting() &amp;&amp; error.get()) &#123;</span><br><span class="line">            <span class="comment">// Connection will be forcibly closed which will prevent</span></span><br><span class="line">            <span class="comment">// completion happening at the usual point. Need to trigger</span></span><br><span class="line">            <span class="comment">// call to onComplete() here.</span></span><br><span class="line">            res.action(ActionCode.ASYNC_POST_PROCESS,  <span class="literal">null</span>);</span><br><span class="line">            async = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Access log</span></span><br><span class="line">        <span class="keyword">if</span> (!async &amp;&amp; postParseSuccess) &#123;</span><br><span class="line">            <span class="comment">// Log only if processing was invoked.</span></span><br><span class="line">            <span class="comment">// If postParseRequest() failed, it has already logged it.</span></span><br><span class="line">            <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> request.getContext();</span><br><span class="line">            <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> request.getHost();</span><br><span class="line">            <span class="comment">// If the context is null, it is likely that the endpoint was</span></span><br><span class="line">            <span class="comment">// shutdown, this connection closed and the request recycled in</span></span><br><span class="line">            <span class="comment">// a different thread. That thread will have updated the access</span></span><br><span class="line">            <span class="comment">// log so it is OK not to update the access log here in that</span></span><br><span class="line">            <span class="comment">// case.</span></span><br><span class="line">            <span class="comment">// The other possibility is that an error occurred early in</span></span><br><span class="line">            <span class="comment">// processing and the request could not be mapped to a Context.</span></span><br><span class="line">            <span class="comment">// Log via the host or engine in that case.</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis() - req.getStartTime();</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">                context.logAccess(request, response, time, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.isError()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (host != <span class="literal">null</span>) &#123;</span><br><span class="line">                    host.logAccess(request, response, time, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    connector.getService().getContainer().logAccess(</span><br><span class="line">                        request, response, time, <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        req.getRequestProcessor().setWorkerThreadName(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recycle the wrapper request and response</span></span><br><span class="line">        <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">            updateWrapperErrorCount(request, response);</span><br><span class="line">            request.recycle();</span><br><span class="line">            response.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="Pipeline和Value"><a href="#Pipeline和Value" class="headerlink" title="Pipeline和Value"></a>Pipeline和Value</h3><p>Tomcat的容器中，内容的执行是通过一个管道来控制的，它定义了一个Pipeline，4个层次的容器都持有了一个Pipeline用以执行预定义好的任务。而具体的任务则装载在Value中，也就是所谓的阀。</p>
<p>在连接适配器中的服务方法通过了调用</p>
<p>connector.getService().getContainer().getPipeline().getFirst().invoke(request, response)的调用将请求转移到容器中执行。它实际就是调用了容器的Pipeline中的任务，即依次执行预定义好的任务(Value)。Pipeline的实现是一个链表结构，我们先看看它其中的节点实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ValveBase</span> <span class="keyword">extends</span> <span class="title class_">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title class_">Contained</span>, Valve &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next Valve in the pipeline this Valve is a component of.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Valve</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Container <span class="title function_">getContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContainer</span><span class="params">(Container container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Valve <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Valve valve)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = valve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述精简过的代码是实现了Value接口的基础类ValueBase，它有一个Value类型的内部属性next，即同一个Pipeline中的后续Value的引用。如果玩过Java数据结构或作STL的基本上不难理解这是一个单向链表的节点。继承这个ValueBase针对不同的容器实现了不同版本的阀如StandardEngineValue，StandardHostValue，StandardContextValue，StandardWrapperValve等。他们之间不同的实现就是invoke和event的方法不同。而实际上也就是请求的路由选择，Filter应用和Servlet的处理。</p>
<p>Pipeline的标准实现是StandardPipeline。它的类注释是</p>
<p><code>Standard implementation of a processing Pipeline that will invoke a series of Valves that have been configured to be called in order.This implementation can be used for any type of Container.</code></p>
<p>意思是它用于依次执行已经配置好的阀。</p>
<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>Tomcat的容器中，有着4个层次的Servlet容器，这4个类型的容器一般情况下是从属的关系.其中顶层的容器为Engine。这个Engine是Tomcat的整个Servlet引擎.它的子容器是Host，默认情况下Tomcat会有一个Engine，它所对应的阀是StandardEngineValve。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从配置中可以知道Service节点除了定义Connector，还定义了Engine，它里面还有一个Host。也就是说StandardService初始化的时候，就构造了Servlet引擎StandardEngine等一系列的容器层次。我们就看看Engine的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StandardEngine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    pipeline.setBasic(<span class="keyword">new</span> <span class="title class_">StandardEngineValve</span>());</span><br><span class="line">    <span class="comment">/* Set the jmvRoute using the system property jvmRoute */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setJvmRoute(System.getProperty(<span class="string">&quot;jvmRoute&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">        log.warn(sm.getString(<span class="string">&quot;standardEngine.jvmRouteFail&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// By default, the engine will hold the reloading thread</span></span><br><span class="line">    backgroundProcessorDelay = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StandardEngine继承自ContainerBase自然也就有了pipeline对象和invoke方法。构造函数中设置的基础阀是StandardEngineValve。它是Engine特有的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Select the Host to be used for this Request</span></span><br><span class="line">    <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> request.getHost();</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// HTTP 0.9 or HTTP 1.0 request without a host when no default host</span></span><br><span class="line">        <span class="comment">// is defined.</span></span><br><span class="line">        <span class="comment">// Don&#x27;t overwrite an existing error</span></span><br><span class="line">        <span class="keyword">if</span> (!response.isError()) &#123;</span><br><span class="line">            response.sendError(<span class="number">404</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">        request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ask this Host to process this request</span></span><br><span class="line">    host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是StandardEngineValve的invoke方法,从中我们可以知道它的作用只是把调用转发给了它的子容器Host,也就是他只起到了一个路由的作用。真正处理请求的还是在它的下级容器。</p>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>Engine是Tomcat的整个Servlet引擎，它的子容器是Host，一般称之为虚拟主机。Engine和Host是一对多的关系，Host既然同为Servlet容器那么它也承担着对请求的处理，主要体现在它的StandardHostValue上面。除此它还有一个重要的功能也就是虚拟主机下的应用的发布，这项功能主要体现在HostConfig上面。</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>Context是Host的子容器，在servlet引擎中它代表了一个web application。它在每一个Catalina中部署的应用几乎都是存在的。它的子容器是Wrapper(一个具体servlet的定义)，Context是标准实现是StandardContext，与StandardHost的实现模式类似。它承担了创建Wrapper容器(Servlet)，Filter，ErrorPage等在web。xml中配置的内容。</p>
<h3 id="Warpper"><a href="#Warpper" class="headerlink" title="Warpper"></a>Warpper</h3><p>Wrapper是Context的子容器,它代表了在应用部署描述中的一个单独的servlet。它通过Servlet的init和destroy方法掌管了底层的Servlet的生命周期。并且其中的阀还负责调用Servlet响应用户请求的功能。Wrapper的默认实现是StandardWrapper。</p>
<p>StandardWrapper的构造函数还是跟StandardContext等类似，也是设置了阀，与它的上层容器不同的是，StandardWrapper已经没有下层容器了，所以在它的addChild方法实现上是直接抛出一个IllegalStateException异常。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/15/12-Tomcat/02-Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/" data-id="clmcxec5q0005u8wae2yj0u52" data-title="Tomcat源码分析2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/15/12-Tomcat/01-Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Tomcat源码分析1
        
      </div>
    </a>
  
  
    <a href="/2020/08/15/12-Tomcat/03-Tomcat%E4%BC%98%E5%8C%96/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Tomcat优化</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ActiveMQ/">ActiveMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dubbo/">Dubbo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/K8s/">K8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kafka/">Kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RabbitMQ/">RabbitMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Socker/">Socker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Zookeeper/">Zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActiveMQ/" rel="tag">ActiveMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CDH/" rel="tag">CDH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dubbo/" rel="tag">Dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDFS/" rel="tag">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K8s/" rel="tag">K8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KDTree/" rel="tag">KDTree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MapReduce/" rel="tag">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/" rel="tag">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socker/" rel="tag">Socker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/" rel="tag">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YARN/" rel="tag">YARN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZooKeeper/" rel="tag">ZooKeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag">注解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" rel="tag">集合源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ActiveMQ/" style="font-size: 10px;">ActiveMQ</a> <a href="/tags/CDH/" style="font-size: 10px;">CDH</a> <a href="/tags/Docker/" style="font-size: 18px;">Docker</a> <a href="/tags/Dubbo/" style="font-size: 13px;">Dubbo</a> <a href="/tags/Golang/" style="font-size: 19px;">Golang</a> <a href="/tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="/tags/K8s/" style="font-size: 10px;">K8s</a> <a href="/tags/KDTree/" style="font-size: 10px;">KDTree</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/MQ/" style="font-size: 10px;">MQ</a> <a href="/tags/MapReduce/" style="font-size: 10px;">MapReduce</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 14px;">Mybatis</a> <a href="/tags/Netty/" style="font-size: 14px;">Netty</a> <a href="/tags/RPC/" style="font-size: 11px;">RPC</a> <a href="/tags/RabbitMQ/" style="font-size: 15px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 17px;">Redis</a> <a href="/tags/Socker/" style="font-size: 10px;">Socker</a> <a href="/tags/Spark/" style="font-size: 11px;">Spark</a> <a href="/tags/Spring/" style="font-size: 20px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/Tomcat/" style="font-size: 13px;">Tomcat</a> <a href="/tags/YARN/" style="font-size: 11px;">YARN</a> <a href="/tags/ZooKeeper/" style="font-size: 12px;">ZooKeeper</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 16px;">多线程</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 10px;">注解</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 11px;">设计模式</a> <a href="/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/" style="font-size: 13px;">集合源码</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/05-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/04-Sharding-JDBC%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/03-MyCat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/02-MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/09/10/11-MySQL/04-MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/01-MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>